<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>ADPanel - <%= bot %></title>

    <link rel="stylesheet" href="/style.css">
    <link id="favicon" rel="icon" type="image/png" href="/images/adpanel-dark.png" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    <script src="/socket.io/socket.io.js"></script>

    <style>
      :root{
        --bg:#0b0f14;
        --card:#0e1116;
        --muted:#9aa3ad;
        --text:#e6eef8;
        --border:rgba(255,255,255,0.06);
        --border-strong:rgba(255,255,255,0.12);
        --accent:#10b981;
        --accent-2:#60a5fa;
        --hover:rgba(255,255,255,0.02);

        /* New awwwards-y vibes */
        --glass:rgba(255,255,255,0.06);
        --glass-2:rgba(255,255,255,0.1);
        --ink:#0b0f14;
        --ink-2:#0f141b;
        --shine:linear-gradient(135deg, rgba(255,255,255,0.08), rgba(255,255,255,0.02));
        --glow:0 10px 30px rgba(0,0,0,0.55), 0 0 0 1px rgba(255,255,255,0.04) inset;
        --ring:0 0 0 1px rgba(255,255,255,0.16);
      }

      .entry-actions { position: relative; }
      .more-btn {
        background: transparent; border: none; color: #bfc8d4; cursor: pointer;
        font-size: 18px; padding: 6px; border-radius: 6px;
        align-self: flex-end;
      }
      .more-btn:hover { background: rgba(255,255,255,0.02); color:#fff; }
      .more-menu {
        position: absolute; left: 0; top: 28px; background: #0f1114;
        border: 1px solid rgba(255,255,255,0.04); box-shadow: 0 8px 30px rgba(0,0,0,0.6);
        border-radius: 8px; overflow: hidden; z-index: 2000; min-width: 160px; display: none;
      }
      .more-menu.show { display: block; }
      .more-menu button {
        display: block; width: 100%; padding: 10px 12px; background: transparent; border: 0;
        color: #c8d1da; text-align: left; font-size: 14px; cursor: pointer;
      }
      .more-menu button:hover { background: rgba(255,255,255,0.02); color:#fff; }

      /* Progress & modals & scrollbars — neschimbate (doar scurtate) */
      .progress-wheel{width:18px;height:18px;border-radius:50%;background:#31343a;display:inline-block;position:relative;overflow:hidden;border:1px solid rgba(255,255,255,0.06);box-shadow: inset 0 1px 0 rgba(0,0,0,0.3);margin-left:10px;vertical-align:middle;cursor:pointer;transition:transform .12s ease, box-shadow .12s ease;}
      .progress-wheel:hover{transform:scale(1.08);box-shadow:0 4px 14px rgba(0,0,0,0.5);}
      .progress-wheel .fill{position:absolute;left:0;right:0;top:0;background:#ffffff;height:0%;border-radius:50%;transition:height 120ms linear;pointer-events:none;}
      .progress-wheel.hidden{display:none;}
      .progress-popup{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:linear-gradient(135deg,rgba(18,20,24,0.92),rgba(28,30,36,0.88));color:#fff;border-radius:12px;border:1px solid rgba(255,255,255,0.06);padding:16px 18px;z-index:100000;min-width:300px;box-shadow:0 12px 40px rgba(0,0,0,0.6);display:none;backdrop-filter:blur(6px) saturate(120%);}
      .progress-popup .row{display:flex;align-items:center;justify-content:space-between;gap:12px;}
      .progress-popup .percent{font-weight:700;font-size:20px;color:#ffffff;}
      .progress-popup .close-btn{background:transparent;border:none;color:#9aa3ad;font-size:18px;cursor:pointer;padding:6px;border-radius:6px;}
      .progress-popup .progress-bar{margin-top:12px;width:100%;height:12px;background:rgba(255,255,255,0.06);border-radius:8px;overflow:hidden;position:relative;}
      .progress-popup .progress-bar .bar{height:100%;width:0%;background:linear-gradient(90deg,rgba(255,255,255,1),rgba(220,220,220,0.85));transition:width 120ms linear;box-shadow:0 2px 8px rgba(0,0,0,0.45) inset;}
      .progress-popup .meta{margin-top:10px;font-size:12px;color:#9aa3ad;display:flex;align-items:center;justify-content:space-between;gap:8px;}

      #dropOverlay{position:absolute;inset:0;display:none;align-items:center;justify-content:center;z-index:99990;pointer-events:none;}
      #dropOverlay.visible{display:flex;pointer-events:auto;}
      #dropOverlay .inner{background:rgba(255,255,255,0.02);border:1px dashed rgba(255,255,255,0.08);padding:26px 32px;border-radius:12px;text-align:center;color:#e6eef8;backdrop-filter:blur(3px);box-shadow:0 8px 30px rgba(0,0,0,0.5);}
      #dropOverlay .inner h3{margin:0 0 6px 0;font-size:18px;}
      #dropOverlay .inner p{margin:0;font-size:13px;color:#b8c3cf;}

      *::-webkit-scrollbar{width:10px;height:10px;} *::-webkit-scrollbar-track{background:transparent;margin:6px 0;border-radius:999px;}
      *::-webkit-scrollbar-thumb{background-color:#212121;border-radius:999px;border:2px solid transparent;background-clip:padding-box;box-shadow:inset 0 0 0 1px rgba(255,255,255,0.02);}
      *::-webkit-scrollbar-thumb:hover{background-color:#2a2a2a;} *::-webkit-scrollbar-corner{background:transparent;}

      #console,#entries,.modal-body,.modal-left,.modal-right,.code-area,textarea,.modal{scrollbar-width:thin;scrollbar-color:#212121 transparent;}
      #console{height:375px;overflow:auto;padding:12px;border-radius:8px;background:#0b0c0e; white-space: pre-wrap; position: relative; width: 1100px;}

      /* FILES LIST – full-width, modern cards */
      #filesModal .modal{
        position:relative;
        width:94vw;
        max-width:1400px;
        height:88vh;
        max-height:88vh;
        display:flex;
        flex-direction:column;
        background:radial-gradient(circle at 0% 0%, rgba(96,165,250,0.08), transparent 50%),
          radial-gradient(circle at 100% 0%, rgba(16,185,129,0.08), transparent 50%),
          linear-gradient(180deg, rgba(14,17,22,0.95), rgba(6,9,12,0.98));
        color:var(--text);
        border:1px solid rgba(255,255,255,0.08);
        border-radius:24px;
        box-shadow:0 35px 90px rgba(0,0,0,0.65);
        overflow:hidden;
      }
      #filesModal .modal-body{
        flex:1;
        display:flex;
        flex-direction:column;
      }
      #filesModal .modal-left{ flex:1; }
      #filesModal .modal-right{ display:none; }

      /* header din Files: breadcrumbs la stânga, Upload/New la dreapta */
      #fileUploadModal{ display:none; } /* ascunde input-ul, folosim label-ul ca buton */

      .file-toolbar{
        display:flex;
        justify-content:space-between;
        align-items:center;
        gap:16px;
        padding:12px 0;
        border-bottom:1px solid rgba(255,255,255,0.05);
      }
      .file-toolbar-left{
        display:flex;
        align-items:center;
        gap:12px;
      }
      .file-toolbar-icon{
        width:44px;
        height:44px;
        border-radius:14px;
        background:rgba(255,255,255,0.05);
        display:flex;
        align-items:center;
        justify-content:center;
        font-size:18px;
        color:#60a5fa;
        box-shadow:inset 0 0 0 1px rgba(255,255,255,0.06);
      }
      .file-toolbar-title{font-size:13px;color:var(--muted);text-transform:uppercase;letter-spacing:0.2em;}
      #breadcrumbs{
        font-size:16px;
        font-weight:600;
        color:#f3f4f6;
      }
      #breadcrumbs a{color:#60a5fa;text-decoration:none;}
      #breadcrumbs a:hover{text-decoration:underline;}
      .file-toolbar-actions{
        display:flex;
        gap:10px;
        align-items:center;
      }
      .ghost-btn{
        border:1px solid rgba(255,255,255,0.08);
        background:rgba(255,255,255,0.02);
        color:#e6eef8;
        border-radius:999px;
        padding:10px 16px;
        font-size:13px;
        display:flex;
        align-items:center;
        gap:8px;
        cursor:pointer;
        transition:all .12s ease;
      }
      .ghost-btn i{font-size:14px;}
      .ghost-btn:hover{
        background:rgba(255,255,255,0.08);
        border-color:rgba(255,255,255,0.22);
        transform:translateY(-1px);
      }

      .file-glance{
        display:grid;
        grid-template-columns:repeat(auto-fit,minmax(240px,1fr));
        gap:12px;
        margin:18px 0;
      }
      .glance-card{
        display:flex;
        align-items:center;
        gap:12px;
        padding:14px 16px;
        border-radius:16px;
        background:rgba(255,255,255,0.02);
        border:1px solid rgba(255,255,255,0.04);
        box-shadow:0 12px 40px rgba(0,0,0,0.4);
      }
      .glance-card .icon{
        width:38px;height:38px;border-radius:12px;display:flex;align-items:center;justify-content:center;font-size:16px;
        color:#10b981;background:rgba(16,185,129,0.12);
      }
      .glance-card:nth-child(2) .icon{color:#60a5fa;background:rgba(96,165,250,0.12);}
      .glance-card:nth-child(3) .icon{color:#f97316;background:rgba(249,115,22,0.12);}
      .glance-label{font-size:13px;text-transform:uppercase;letter-spacing:0.08em;color:#9aa3ad;}
      .glance-desc{font-size:15px;font-weight:600;color:#f8fafc;}

      /* grid entries mare cât popup-ul */
      #entries{
        flex:1;
        overflow:auto;
        padding:4px 0 0;
        display:grid;
        grid-template-columns:repeat(auto-fill,minmax(257px,1fr));
        gap:16px;
        list-style:none;
        margin:0;
        align-content:start;
      }

      /* Modern file cards */
      .entry{
        display:grid;
        grid-template-columns:auto 1fr auto;
        align-items:center;
        gap:16px;
        padding:16px 18px;
        border-radius:18px;
        background:rgba(9,12,18,0.9);
        border:1px solid rgba(255,255,255,0.05);
        box-shadow:0 15px 45px rgba(0,0,0,0.55);
        transition:transform .12s ease, box-shadow .12s ease, border-color .12s ease, background .12s ease;
      }
      .entry:hover{
        background:rgba(12,17,25,0.98);
        border-color:rgba(255,255,255,0.18);
        transform:translateY(-3px);
        box-shadow:0 25px 65px rgba(0,0,0,0.6);
      }
      .entry-left{display:flex;align-items:center;gap:14px;}
      .entry-icon{
        width:48px;height:48px;border-radius:16px;
        display:flex;align-items:center;justify-content:center;
        background:rgba(96,165,250,0.08);
        color:#60a5fa;
        font-size:20px;
        box-shadow:inset 0 0 0 1px rgba(96,165,250,0.3);
      }
      .entry-icon.folder{background:rgba(250,204,21,0.12);color:#facc15;box-shadow:inset 0 0 0 1px rgba(250,204,21,0.35);}
      .entry-name{ font-size:16px; font-weight:700; color:var(--text); }
      .entry-meta{ font-size:13px; color:var(--muted); margin-top:3px; letter-spacing:0.08em; font-variant:all-small-caps; text-transform:none; }
      .entry-arrow{color:#9aa3ad;font-size:14px;opacity:0;transition:opacity .12s ease, transform .12s ease;}
      .entry:hover .entry-arrow{opacity:1;transform:translateX(4px);}
      .entry-actions{justify-self:end;}
      .entry-right{display:flex;align-items:center;gap:10px;justify-content:flex-end;}

      /* Modern editor (larg) */
      #editorModal .modal{
        width:92vw;
        max-width:1280px;
        max-height:90vh;
        display:flex;
        flex-direction:column;
        background:var(--bg);
        color:var(--text);
      }
      #bigEditor{ margin-top:10px; display:flex; flex-direction:column; gap:10px; }

      /* Code area – line numbers */
      .code-area{
        width:100%;
        max-height:60vh;
        overflow:auto;
        padding:0;
        background:#05070b;
        border-radius:10px;
        border:1px solid rgba(148,163,184,0.45);
        font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        font-size:13px;
        line-height:1.4;
        counter-reset:line;
      }
      .code-area div {
        position: relative;
        padding: 0px 12px 0px 36px;
        min-height: 18px;
        white-space: pre;
      }
      .code-area div::before {
        counter-increment: line;
        content: counter(line);
        position: absolute;
        left: 8px;
        top: 2.5px;
        bottom: 0;
        display: flex;
        align-items: flex-start;
        justify-content: flex-end;
        width: 22px;
        font-size: 11px;
        color: #4b5563;
      }
      textarea{
        width:100%;
        max-height:60vh;
        overflow:auto;
        padding:10px;
        border-radius:10px;
        border:1px solid rgba(148,163,184,0.45);
        background:#05070b;
        color:#e6eef8;
        font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        font-size:13px;
        resize:vertical;
      }
      .code-area:focus, #textArea:focus{ outline:none; box-shadow:none; border-color:rgba(59,130,246,0.8); }

      /* Syntax highlight colors */
      .code-area .kw{color:#93c5fd;}
      .code-area .str{color:#f97316;}
      .code-area .num{color:#a5b4fc;}
      .code-area .com{color:#6b7280;font-style:italic;}
      .code-area .fn{color:#4ade80;}
      .code-area .cls{color:#facc15;}
      .code-area .prop{color:#f9a8d4;}
      .code-area .tag{color:#f97316;}
      .code-area .attr{color:#fde68a;}

      /* Dock */
      .dock-wrap{
        position:fixed; right:18px; bottom:18px; width:520px; z-index:99999; max-width:100%;
      }
      .dock{
        display:flex; gap:12px; background:rgba(11,12,14,0.78);
        padding:10px 18px; border-radius:16px; width:100%;
        box-shadow:0 8px 26px rgba(0,0,0,0.65); align-items:center;
      }
      .dock-item{ display:flex; flex-direction:column; align-items:center; gap:6px; padding:8px 10px; cursor:pointer; user-select:none; color:#d1d8de; text-decoration:none; }
      .dock-item .icon{ width:36px; height:36px; display:flex; align-items:center; justify-content:center; border-radius:8px; }
      .dock-item .label{ font-size:11px; color:#c3cad2; margin-top:4px; }
      .dock-item:hover{ transform:translateY(-3px); transition:transform .12s; }

      .info-grid{display:grid;gap:10px;}
      .info-row{display:flex;align-items:center;justify-content:space-between;gap:12px;padding:10px 12px;background:#0e1116;border:1px solid rgba(255,255,255,0.05);border-radius:10px;}
      .info-key{color:#9aa3ad;font-size:13px;}
      .info-val{color:#e6eef8;font-weight:700;font-size:14px;word-break:break-all;}
      .addr-wrap{display:flex;gap:8px;align-items:center;}
      .addr-input{flex:1;padding:10px 12px;border-radius:10px;background:#0b0f14;color:#e6eef8;border:1px solid rgba(255,255,255,0.06);outline:none;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;}
      .copy-btn{background:#10b981;color:#041015;border:0;border-radius:10px;padding:10px 14px;font-weight:700;cursor:pointer;box-shadow:0 6px 18px rgba(16,185,129,.25);}
      .copy-btn:hover{filter:brightness(1.06);}
      .modal .hint{font-size:12px;color:#9aa3ad;}
      .disabled{opacity:.5;pointer-events:none;filter:saturate(.3);}
      .hidden{display:none !important;}

      /* === Store modal (Awwwards redesign) === */
      #storeModal .modal{
        width:90vw; max-width:1200px; height:90vh; max-height:90vh;
        display:flex; flex-direction:column;
        color:var(--text);
        background:
          radial-gradient(1000px 600px at 120% -10%, rgba(96,165,250,0.08), transparent 60%),
          radial-gradient(900px 500px at -10% 120%, rgba(16,185,129,0.10), transparent 60%),
          linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
        backdrop-filter: blur(10px) saturate(150%);
        border:1px solid rgba(255,255,255,0.08);
        border-radius:18px;
        box-shadow:0 30px 80px rgba(0,0,0,0.6);
      }
      .store-header{
        display:flex;align-items:center;justify-content:space-between;gap:16px;
        padding:18px 18px 12px 18px;
        border-bottom:1px solid rgba(255,255,255,0.08);
        position:relative;
      }
      .store-header:after{
        content:""; position:absolute; left:18px; right:18px; bottom:-1px; height:1px;
        background:linear-gradient(90deg, transparent, rgba(255,255,255,0.22), transparent);
        opacity:.3;
      }
      .store-header-main{display:flex;align-items:center;gap:12px;}
      .store-subtitle{color:#b8c3cf;font-size:12.5px;margin-top:4px;}
      .store-header-right{display:flex;align-items:center;gap:10px;}
      .store-tabs{display:flex;align-items:center;gap:8px;background:rgba(255,255,255,0.04);padding:6px;border-radius:999px;border:1px solid rgba(255,255,255,0.06);}
      .store-tab{
        border-radius:999px;border:1px solid rgba(255,255,255,0.1);
        background:transparent;
        color:#e5edf7;font-size:13px;padding:8px 14px;cursor:pointer;white-space:nowrap;
        transition:all .15s ease;
      }
      /* Active = alb, nu negru */
      .store-tab.active{
        background:#ffffff;color:#0b0f14;border-color:#ffffff;
        box-shadow:0 6px 18px rgba(255,255,255,0.1), 0 0 0 2px rgba(255,255,255,0.08);
      }
      .store-tab:hover{transform:translateY(-1px);}

      .store-close{border-radius:999px;}

      .store-body{flex:1;display:flex;flex-direction:column;overflow:hidden;}
      #storeContent{flex:1;margin-top:8px;overflow:auto;padding:12px 14px 14px 14px;}
      .store-content-grid{
        display:grid;grid-template-columns:repeat(auto-fill,minmax(240px,1fr));
        gap:14px;align-content:flex-start;
      }

      /* Provider card – premium */
      .store-provider-card{
        display:flex;align-items:center;justify-content:space-between;gap:12px;
        padding:14px;border-radius:16px;
        background:rgba(255,255,255,0.04);
        border:1px solid rgba(255,255,255,0.06);
        cursor:pointer;text-align:left;
        transition:transform .18s ease, box-shadow .18s ease, border-color .18s ease, background .18s ease;
        position:relative; overflow:hidden;
      }
      .store-provider-card:before{
        content:""; position:absolute; inset:0; background:linear-gradient(120deg, transparent 30%, rgba(255,255,255,0.05), transparent 70%);
        transform:translateX(-100%); transition:transform .6s ease;
      }
      .store-provider-card:hover:before{ transform:translateX(100%); }
      .store-provider-card:hover{
        background:rgba(255,255,255,0.06);
        border-color:rgba(255,255,255,0.14);
        transform:translateY(-2px);
        box-shadow:0 20px 50px rgba(0,0,0,0.55);
      }
      .store-provider-logo{
        width:46px;height:46px;border-radius:12px;background:rgba(255,255,255,0.06);
        display:flex;align-items:center;justify-content:center;overflow:hidden;border:1px solid rgba(255,255,255,0.08);
      }
      .store-provider-logo img{width:36px;height:36px;object-fit:contain;filter:drop-shadow(0 4px 10px rgba(0,0,0,0.5));}
      .store-provider-logo-placeholder{font-weight:800;font-size:18px;color:#e5edf7;}
      .store-provider-body{flex:1;min-width:0;}
      .store-provider-name{font-size:15px;font-weight:700;color:#e6eef8;letter-spacing:.2px;}
      .store-provider-desc{font-size:12.5px;color:#9aa3ad;margin-top:3px;opacity:.9;}
      .store-provider-chevron{color:#aab3bf;font-size:13px;}

      /* Provider details header — logo + text side by side (nu sub) */
      .store-provider-header{
        display:flex;align-items:center;justify-content:space-between;gap:14px;margin-bottom:12px;
      }
      .store-provider-header-main{
        display:flex;align-items:center;gap:12px;flex:1;min-width:0;
        padding:10px 12px;border-radius:14px;background:rgba(255,255,255,0.04);
        border:1px solid rgba(255,255,255,0.06);
      }
      .store-provider-header-logo{width:40px;height:40px;object-fit:contain;}
      .store-provider-header-name{font-size:16px;font-weight:800;color:#e6eef8;}
      .store-provider-header-desc{font-size:12.5px;color:#9aa3ad;margin-top:2px;}
      .store-back-btn{
        border-radius:12px;border:1px solid rgba(255,255,255,0.1);
        background:rgba(255,255,255,0.06);color:#e5edf7;font-size:12.5px;padding:8px 12px;cursor:pointer;display:flex;align-items:center;gap:6px;
      }
      .store-back-btn:hover{background:rgba(255,255,255,0.1);transform:translateY(-1px);}

      .store-note{font-size:12.5px;color:#9aa3ad;margin-bottom:10px;padding-left:2px;}

      .store-version-list{display:flex;flex-direction:column;gap:10px;}
      .store-version-row{
        display:flex;align-items:center;justify-content:space-between;gap:10px;
        padding:12px 14px;border-radius:14px;background:rgba(255,255,255,0.03);
        border:1px solid rgba(255,255,255,0.06);cursor:pointer;
        transition: transform .12s ease, background .12s ease, border-color .12s ease, box-shadow .12s ease;
      }
      .store-version-row:hover{
        background:rgba(255,255,255,0.06);border-color:rgba(255,255,255,0.12);transform:translateY(-1px);
        box-shadow:0 12px 30px rgba(0,0,0,0.45);
      }
      .store-version-meta{min-width:0;}
      .store-version-name{font-size:14px;font-weight:700;color:#e6eef8;}
      .store-version-sub{font-size:12px;color:#9aa3ad;margin-top:2px;}
      .store-version-tags{display:flex;flex-wrap:wrap;gap:6px;justify-content:flex-end;}
      .pill{display:inline-flex;align-items:center;border-radius:999px;padding:4px 9px;font-size:11px;font-weight:700;letter-spacing:.3px;}
      .pill-green{background:rgba(16,185,129,0.16);color:#bbf7d0;border:1px solid rgba(16,185,129,0.4);}
      .pill-muted{background:rgba(148,163,184,0.16);color:#e5e7eb;border:1px solid rgba(148,163,184,0.45);}

      .store-placeholder,.store-empty,.store-loading,.store-error{font-size:13px;color:#9aa3ad;padding:8px;}
      .store-error{color:#fecaca;}

      /* === Modrinth plugins UI in Store (cards kept) === */
      .mr-plugins-root{display:flex;flex-direction:column;height:100%;}
      .mr-plugins-header{display:flex;align-items:center;gap:8px;margin-bottom:10px;}
      .mr-plugins-header input{
        flex:1;padding:10px 12px;border-radius:999px;border:1px solid rgba(255,255,255,0.14);
        background:rgba(255,255,255,0.04);color:var(--text);font-size:13px;outline:none;
      }
      .mr-plugins-header input::placeholder{color:#9aa3ad;}
      .mr-plugin-grid{
        flex:1;display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:12px;align-content:flex-start;overflow:auto;padding-right:4px;
      }
      .mr-plugin-card{
        display:flex;flex-direction:column;border-radius:16px;background:rgba(255,255,255,0.04);
        border:1px solid rgba(255,255,255,0.06);padding:10px;cursor:pointer;
        transition:transform .12s ease, box-shadow .12s ease, border-color .12s ease, background .12s ease;
        position:relative;
      }
      .mr-plugin-card:hover{
        background:rgba(255,255,255,0.08);border-color:rgba(255,255,255,0.14);
        transform:translateY(-2px);box-shadow:0 16px 40px rgba(0,0,0,0.55);
      }
      .mr-plugin-icon{width:100%;height:140px;border-radius:10px;object-fit:cover;margin-bottom:10px;box-shadow:inset 0 0 0 1px rgba(255,255,255,0.06);}
      .mr-plugin-title{font-size:14px;font-weight:700;color:var(--text);}
      .mr-plugin-desc{font-size:12px;color:var(--muted);margin-top:4px;min-height:32px;}
      .mr-plugin-footer{display:flex;align-items:center;justify-content:space-between;margin-top:10px;gap:6px;}
      .mr-plugin-install-btn{
        border-radius:999px;border:0;background:#10b981;color:#02110b;font-size:12px;padding:8px 12px;cursor:pointer;white-space:nowrap;font-weight:800;
      }
      .mr-plugin-install-btn:hover{filter:brightness(1.08);transform:translateY(-1px);}

      /* Section titles */
      .sectionTitle{font-size:15px;margin-top:8px;font-weight:700;color:var(--text);}

      /* OLD .boxGrid kept (unused in new modal for selects but backward-compatible) */
      .boxGrid{margin-top:10px;display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:10px;}
      .selectBox{background:#0e1116;border-radius:10px;border:1px solid rgba(255,255,255,0.06);padding:10px;font-size:13px;text-align:center;cursor:pointer;color:var(--text);transition:background .1s ease, border-color .1s ease, transform .1s ease, box-shadow .1s ease;}
      .selectBox:hover{background:#10141b;border-color:rgba(255,255,255,0.16);transform:translateY(-1px);box-shadow:0 8px 22px rgba(0,0,0,0.5);}
      .selectBox.selected{background:#022c22;border-color:#10b981;box-shadow:0 0 0 1px rgba(16,185,129,0.5);}

      .downloadBtnFinal{margin-top:18px;border-radius:999px;border:0;padding:10px 14px;font-size:14px;font-weight:800;cursor:pointer;background:#3b82f6;color:white;}
      .downloadBtnFinal:disabled{opacity:0.5;cursor:not-allowed;}

      /* === Install Plugin Modal — Awwwards redesign with SELECTORS === */
      #mrPluginModal .modal{
        width:860px; max-width:92vw;
        display:flex; flex-direction:column;
        background:
          radial-gradient(900px 500px at 120% -20%, rgba(96,165,250,0.10), transparent 60%),
          radial-gradient(900px 500px at -10% 120%, rgba(16,185,129,0.12), transparent 60%),
          linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
        border:1px solid rgba(255,255,255,0.1);
        border-radius:20px;
        color:var(--text);
        box-shadow:0 35px 90px rgba(0,0,0,0.65);
        backdrop-filter: blur(150px);
      }
      #mrPluginModal .modal-header{
        padding:18px;border-bottom:1px solid rgba(255,255,255,0.08);
        display:flex;align-items:center;justify-content:space-between;
      }
      #mrPluginModal .modal-title{font-size:18px;font-weight:900;letter-spacing:.3px;}
      #mrPluginModal .modal-body{padding:16px;display:flex;flex-direction:column;gap:14px;}

      /* Select controls */
      .select-control{display:flex;flex-direction:column;gap:8px;}
      .select-control label{font-size:12.5px;color:#aeb8c5;font-weight:700;letter-spacing:.2px;}
      .select-wrap{
        position:relative; display:block;
        background:rgba(255,255,255,0.05);
        border:1px solid rgba(255,255,255,0.12);
        border-radius:12px; padding:0; overflow:hidden;
      }
      .select-wrap select{
        appearance:none; -webkit-appearance:none; -moz-appearance:none;
        width:100%; background:transparent; border:0; outline:none;
        background-color: black;
        color:#cfcfcfd7; padding:12px 40px 12px 12px; font-weight:700; letter-spacing:.2px;
        cursor:pointer;
      }
      .select-wrap i{
        position:absolute; right:12px; top:50%; transform:translateY(-50%); pointer-events:none; color:#9fb0c5; font-size:14px;
      }

      /* Footer actions */
      #mrPluginModal .downloadBtnFinal{
        align-self:flex-end; padding:12px 16px; font-size:13.5px; letter-spacing:.3px; background:#10b981;color:#ffffff;
        border-radius:14px; border:0; font-weight:900;
        box-shadow:0 10px 22px rgba(16,185,129,.18);
      }
      #mrPluginModal .downloadBtnFinal:hover{filter:brightness(1.06); transform:translateY(-1px);}
      #mrPluginModal .downloadBtnFinal:disabled{opacity:.5; transform:none;}

      /* Info chips under title */
      .mr-title-sub{font-size:12.5px;color:#aeb8c5;margin-top:4px;}

      /* Modal overlay shells (kept) */
      .modal-overlay{position:fixed;left:0;top:0;right:0;bottom:0;background:rgba(0,0,0,0.6);display:none;align-items:center;justify-content:center;z-index:10000;}
      .modal-overlay.show{display:flex;}

      /* General buttons */
      .icon-btn{
        border-radius:10px;border:1px solid rgba(255,255,255,0.10);
        background:rgba(255,255,255,0.04);color:#e6eef8;
        padding:8px 12px; font-weight:700; cursor:pointer;
        transition: all .15s ease;
      }
      .icon-btn:hover{background:rgba(255,255,255,0.10);transform:translateY(-1px);}

      .modal{background:var(--ink-2); border:1px solid var(--border); border-radius:14px; backdrop-filter: blur(100px);}
      .modal-header{display:flex;align-items:center;justify-content:space-between;padding:12px 14px;border-bottom:1px solid rgba(255,255,255,0.06);}
      .modal-title{font-weight:800;font-size:16px;}
      .modal-close{background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.1);color:#e6eef8;border-radius:10px;padding:6px 8px;cursor:pointer;}
      .modal-body{padding:12px 14px;}

      /* Topbar tweaks */
      .topbar .icon-btn{font-weight:800}
      .window-header .dot{width:12px;height:12px;border-radius:50%;display:inline-block}

      .jump-btn{
        position: fixed; right: 32px; bottom: 90px; z-index: 20; padding: 6px 10px;
        border-radius: 8px; border: 1px solid rgba(255,255,255,0.12); background: rgba(0,0,0,0.45);
        color: #fff; cursor: pointer; backdrop-filter: blur(2px);
        opacity: 0; visibility: hidden; transform: translateY(6px);
        transition: opacity .15s ease, transform .15s ease, visibility 0s linear .15s;
      }
      .jump-btn:hover{ background: rgba(0,0,0,0.6); }
      .jump-btn i{ pointer-events: none; }
      .jump-btn.show{ opacity: 1; visibility: visible; transform: translateY(0); transition: opacity .15s ease, transform .15s ease, visibility 0s; }

      .command:focus { outline: none; box-shadow: none; }

      .icon-stop {
        width: 70px; height: 33px; cursor: pointer; border: none;
        border: 0.1px solid rgba(182, 182, 182, 0.103); color: gray; background-color: transparent; opacity: 1; border-radius: 12px;
      }
    </style>
  </head>

  <body>
    <div class="app-wrap">
      <div class="topbar">
        <div class="brands">
          <div class="logo" title="Settings"><a href="/"><img src="https://i.imgur.com/k5agjYf.png" alt="adpanel-logo" width="7%" height="7%"></a></div>
          <div class="logo" title="Setups"><a href="/" style="position:absolute;font-family:sans-serif;font-size:30px;font-weight:bold;margin-top:-35px;margin-left:60px;text-decoration:none;color:white;">Panel</a></div>
        </div>

        <div class="top-actions">
          <button class="icon-btn" id="filesBtn" onclick="openFilesModal()"><i class="fa-solid fa-folder-open"></i> Files</button>
          <button class="icon-btn" id="taskBtn" onclick="openTaskModal()"><i class="fa-solid fa-list-check"></i> Task</button>
          <button class="icon-btn" id="storeBtn" onclick="openStoreModal()"><i class="fa-solid fa-store"></i> Store</button>
          <button class="icon-btn" onclick="openInfoModal()"><i class="fa-solid fa-circle-info"></i> Informations</button>
          <button class="icon-btn" id="runBtn" onclick="run()" title="Run selected"><i class="fa-solid fa-play"></i> Run</button>
          <button class="icon-stop" id="stopBtn" onclick="stop()" title="Stop process"><i class="fa-solid fa-stop"></i> Stop</button>
        </div>
      </div>

      <div class="main-stage" style="margin-top:2px">
        <div class="console-panel" role="main" aria-label="Console panel" style="position: absolute; display: flex; justify-content: center; align-items: center; margin-left: 20px;">
          <div class="console-window" style="height: 500px; backdrop-filter: blur(15px);">
            <div class="window-header">
              <div style="display:flex;align-items:center;gap:8px">
                <span class="dot" style="background:#ff5f56;cursor:pointer" onclick="stop()"></span>
                <span class="dot" style="background:#ffbd2e;cursor:pointer" onclick="stop()"></span>
                <span class="dot" style="background:#27c93f;cursor:pointer" onclick="run()"></span>
                <div style="margin-left:6px;color:var(--muted);font-size:13px">Console — <span style="color:#fff;font-weight:700"><%= bot %></span></div>
              </div>
              <div class="window-controls">
                <div style="color:var(--muted);font-size:13px">Status: <span id="statusLabel">idle</span></div>
              </div>
            </div>

            <div class="controls">
              <select id="scriptSelect" title="Choose startup file (.js, .jar, .html, orice)"></select>
              <button class="run-button" id="miniRunBtn" onclick="run()" title="Run"><i class="fa-solid fa-play" style="transform:rotate(90deg)"></i></button>
              <button class="stop-button" id="miniStopBtn" onclick="stop()" title="Stop"><i class="fa-solid fa-stop"></i></button>
              <div style="flex:1"></div>
            </div>

            <pre id="console" aria-live="polite"></pre>

            <div class="cmd-row" id="cmdRow" style="margin-top: 4px;">
              <input id="cmdInput" class="command" type="text" placeholder="Type a command and press Enter (will be sent to running process)" />
              <button class="icon-btn" id="sendBtn" onclick="sendCommand()" title="Send">Send</button>
              <button class="icon-btn" id="clearBtn" onclick="clearConsole()" title="Clear">Clear</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Informations Modal -->
    <div id="infoModal" class="modal-overlay" aria-hidden="true">
      <div class="modal" role="dialog" aria-modal="true" aria-labelledby="infoModalTitle">
        <div class="modal-header">
          <div>
            <div class="modal-title" id="infoModalTitle">Server Informations — <span style="color:#fff;font-weight:700"><%= bot %></span></div>
            <div style="color:var(--muted);font-size:13px">Quick connection details pulled from servers.json</div>
          </div>
          <div><button class="modal-close" id="infoModalClose" title="Close (Esc)"><i class="fa-solid fa-xmark"></i></button></div>
        </div>
        <div class="modal-body">
          <div class="info-grid">
            <div class="info-row"><div class="info-key">IP</div><div class="info-val" id="infoIp">—</div></div>
            <div class="info-row"><div class="info-key">Port</div><div class="info-val" id="infoPort">—</div></div>
            <div class="info-row" style="flex-direction:column;align-items:stretch;">
              <div class="info-key" style="margin-bottom:6px;">Connection Address</div>
              <div class="addr-wrap">
                <input id="infoAddress" class="addr-input" type="text" readonly value="" />
                <button id="copyAddressBtn" class="copy-btn"><i class="fa-solid fa-copy"></i>&nbsp;Copy</button>
              </div>
              <div class="hint" style="margin-top:6px;">This is the address you can share: IP and port combined.</div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Files Modal -->
    <div id="filesModal" class="modal-overlay" aria-hidden="true">
      <div class="modal" role="dialog" aria-modal="true" aria-labelledby="filesModalTitle" style="position:relative;">
        <div class="modal-header">
          <div style="display:flex;align-items:center;gap:8px">
            <div>
              <div class="modal-title" id="filesModalTitle">File Manager — <span style="color:#fff;font-weight:700"><%= bot %></span></div>
              <div style="color:var(--muted);font-size:13px">Explore and manage files</div>
            </div>
            <div id="progressWheel" class="progress-wheel hidden" title="Operation in progress">
              <div class="fill" id="progressFill" style="height:0%"></div>
            </div>
          </div>
          <div><button class="modal-close" id="filesModalClose" title="Close (Esc)"><i class="fa-solid fa-xmark"></i></button></div>
        </div>

        <div id="dropOverlay" aria-hidden="true">
          <div class="inner">
            <h3 id="dropTitle">Drop files here to upload</h3>
            <p id="dropSubtitle">Release to upload to current folder</p>
            <div class="hint">Accepted: files & common archives (zip, tar.gz, rar, 7z)</div>
          </div>
        </div>

        <div class="modal-body">
          <div class="modal-left">
            <div class="file-toolbar">
              <div class="file-toolbar-left">
                <div class="file-toolbar-icon"><i class="fa-solid fa-folder-tree"></i></div>
                <div>
                  <div class="file-toolbar-title">Working directory</div>
                  <div id="breadcrumbs"></div>
                </div>
              </div>
              <div class="file-toolbar-actions">
                <label class="ghost-btn" id="uploadLabel" for="fileUploadModal" style="cursor:pointer"><i class="fa-solid fa-upload"></i> Upload</label>
                <input id="fileUploadModal" type="file" />
                <button class="ghost-btn" id="newBtn" onclick="createNew()" title="New file/folder"><i class="fa-solid fa-file-circle-plus"></i> New</button>
              </div>
            </div>

            <div class="file-glance">
              <div class="glance-card">
                <div class="icon"><i class="fa-solid fa-cloud-arrow-up"></i></div>
                <div>
                  <div class="glance-label">Uploads</div>
                  <div class="glance-desc">Drag & drop anywhere</div>
                </div>
              </div>
            </div>

            <ul id="entries" role="list"></ul>
          </div>

          <div class="modal-right"></div>
        </div>
      </div>
    </div>

    <!-- Task Modal -->
    <div id="taskModal" class="modal-overlay task-modal" aria-hidden="true">
      <div class="modal" role="dialog" aria-modal="true" aria-labelledby="taskModalTitle">
        <div class="modal-header">
          <div>
            <div class="modal-title" id="taskModalTitle">Task Manager — Startup</div>
            <div style="color:var(--muted);font-size:13px">Choose a startup file to use when you press Run</div>
          </div>
          <div><button class="modal-close" id="taskModalClose" title="Close (Esc)"><i class="fa-solid fa-xmark"></i></button></div>
        </div>

        <div style="padding:6px 0 12px 0">
          <div style="display:flex;gap:8px;align-items:center">
            <select id="taskStartupSelect" style="flex:1;padding:10px;border-radius:8px;background:#0e1116;border:1px solid rgba(255,255,255,0.02);color:#fff"></select>
            <button class="icon-btn" id="saveStartupBtn">Save</button>
          </div>
          <div style="color:var(--muted);font-size:13px;margin-top:8px">Saved startup choice is persisted in browser (localStorage).</div>
        </div>
      </div>
    </div>

    <!-- Editor Modal -->
    <div id="editorModal" class="modal-overlay editor-modal" aria-hidden="true">
      <div class="modal" role="dialog" aria-modal="true" aria-labelledby="editorModalTitle">
        <div class="editor-header">
          <div>
            <div class="editor-title" id="editorModalTitle">Editor</div>
            <div style="color:var(--muted);font-size:13px" id="editorPath"></div>
          </div>
          <div class="editor-actions">
            <button class="modal-close" id="editorModalClose" title="Close (Esc)"><i class="fa-solid fa-xmark"></i></button>
          </div>
        </div>

        <div id="bigEditor">
          <div id="codeArea" class="code-area" contenteditable="true" spellcheck="false" style="display:none"></div>
          <textarea id="textArea" style="display:none"></textarea>

          <div style="display:flex;gap:8px;justify-content:flex-end">
            <button class="icon-btn" id="editorDiscard">Discard</button>
            <button class="icon-btn" id="editorSave">Save</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Store Modal -->
    <div id="storeModal" class="modal-overlay" aria-hidden="true">
      <div class="modal" role="dialog" aria-modal="true" aria-labelledby="storeModalTitle">
        <div class="store-header">
          <div class="store-header-main">
            <div>
              <div class="modal-title" id="storeModalTitle">
                Store — <span style="color:#fff;font-weight:700"><%= bot %></span>
              </div>
              <div class="store-subtitle" id="storeSubtitle">Choose your core distribution and manage plugins.</div>
            </div>
          </div>
          <div class="store-header-right">
            <div class="store-tabs" id="storeTabs">
              <button class="store-tab active" id="storeTabVersions"><i class="fa-solid fa-cubes-stacked"></i>&nbsp; Versions</button>
              <button class="store-tab" id="storeTabPlugins"><i class="fa-solid fa-plug"></i>&nbsp; Plugins/Mods</button>
            </div>
            <button class="modal-close store-close" id="storeModalClose" title="Close (Esc)">
              <i class="fa-solid fa-xmark"></i>
            </button>
          </div>
        </div>
        <div class="store-body">
          <div id="storeContent"></div>
        </div>
      </div>
    </div>

    <!-- Modrinth Plugin Modal -->
    <div id="mrPluginModal" class="modal-overlay" aria-hidden="true">
      <div class="modal" role="dialog" aria-modal="true" aria-labelledby="mrPluginModalTitle">
        <div class="modal-header">
          <div>
            <div class="modal-title" id="mrPluginModalTitle">Install Plugin</div>
            <div class="mr-title-sub" id="mrPluginName"></div>
          </div>
          <div><button class="modal-close" id="mrPluginModalClose" title="Close (Esc)"><i class="fa-solid fa-xmark"></i></button></div>
        </div>
        <div class="modal-body">
          <div class="select-control">
            <label for="mrPlatformSelect">Platform</label>
            <div class="select-wrap">
              <!-- Populated dynamically -->
              <select id="mrPlatformSelect" aria-label="Select platform"></select>
              <i class="fa-solid fa-chevron-down"></i>
            </div>
          </div>

          <div class="select-control">
            <label for="mrVersionSelect">Minecraft Version</label>
            <div class="select-wrap">
              <!-- Populated dynamically -->
              <select id="mrVersionSelect" aria-label="Select Minecraft version"></select>
              <i class="fa-solid fa-chevron-down"></i>
            </div>
          </div>

          <button id="mrPluginInstallBtn" class="downloadBtnFinal" disabled>Install Plugin</button>
        </div>
      </div>
    </div>

    <!-- Dock -->
    <div class="dock-wrap" role="navigation" aria-label="taskbar">
      <div class="dock">
        <div class="dock-item" onclick="window.location='/'" title="Dashboard">
          <div class="icon"><i class="fa-solid fa-house" style="color:white;"></i></div>
          <div class="label">Home</div>
        </div>

        <div class="sep" aria-hidden="true"></div>

        <div class="dock-item" id="dockFiles" onclick="openFilesModal()" title="Files">
          <div class="icon"><i class="fa-solid fa-folder-open" style="color:#60a5fa;"></i></div>
          <div class="label">Files</div>
        </div>
        <div class="dock-item" id="dockTask" onclick="openTaskModal()" title="Task Manager">
          <div class="icon"><i class="fa-solid fa-list-check" ></i></div>
          <div class="label">Task</div>
        </div>
        <div class="dock-item" id="dockInfo" onclick="openInfoModal()" title="Informations">
          <div class="icon"><i class="fa-solid fa-circle-info"></i></div>
          <div class="label">Informations</div>
        </div>
        <div class="dock-item" id="dockStore" onclick="openStoreModal()" title="Store">
          <div class="icon"><i class="fa-solid fa-store"></i></div>
          <div class="label">Store</div>
        </div>
        <div class="dock-item" id="dockRun" onclick="run()" title="Run">
          <div class="icon"><i class="fa-solid fa-play" style="color:#10b981;"></i></div>
          <div class="label">Run</div>
        </div>
        <div class="dock-item" id="dockStop" onclick="stop()" title="Stop">
          <div class="icon"><i class="fa-solid fa-stop" style="color:#f97316;"></i></div>
          <div class="label">Stop</div>
        </div>
        <div class="dock-item" id="dockNew" onclick="createNew()" title="Create new">
          <div class="icon"><i class="fa-solid fa-file-circle-plus" style="color:#38bdf8;"></i></div>
          <div class="label">New</div>
        </div>
      </div>
    </div>

    <div id="progressPopup" class="progress-popup" role="dialog" aria-hidden="true">
      <div class="row">
        <div>
          <div class="title">Current Operation</div>
          <div class="percent" id="popupPercent">0%</div>
        </div>
        <div><button id="popupClose" class="close-btn" title="Close">✕</button></div>
      </div>
      <div class="progress-bar" aria-hidden="true"><div class="bar" id="popupBar" style="width:0%"></div></div>
      <div class="meta"><div id="popupMsg">Processing...</div><div id="popupTime" style="font-size:12px;color:#88929b">—</div></div>
    </div>

    <script>
      const bot = "<%= bot %>";
      const socket = io();

      // ====== NEW: Topology / Node-aware API ======
      let REMOTE_MODE = false;
      let NODE_ID = null;
      let NODE_API_BASE = `/api/nodes/server/${encodeURIComponent(bot)}`;

      let logSource = null;
      function attachLogStreamIfRemote(){
        if (!REMOTE_MODE) return;
        try { if (logSource) { logSource.close(); logSource = null; } } catch {}
        const url = `${NODE_API_BASE}/logs`;
        const es = new EventSource(url);
        logSource = es;
        es.addEventListener('hello', (e) => {});
        es.addEventListener('keepalive', () => {});
        es.onmessage = (ev) => {
          try {
            const j = JSON.parse(ev.data);
            if (j && typeof j.line === 'string') {
              appendToConsole(j.line);
            }
          } catch {
            appendToConsole(ev.data || "");
          }
        };
        es.onerror = () => {};
      }
      window.addEventListener('beforeunload', () => { try { if (logSource) logSource.close(); } catch {} });

      // API wrappers
      async function topoInfo(){
        try{
          const r = await fetch(`${NODE_API_BASE}/info`);
          if(!r.ok) throw new Error('nodes info not ok');
          const j = await r.json();
          REMOTE_MODE = !!j.remote; NODE_ID = j.nodeId || null;
          return j;
        }catch(e){
          REMOTE_MODE = false; NODE_ID = null;
          return null;
        }
      }
      async function apiExplore(path=""){
        const url = REMOTE_MODE
          ? `${NODE_API_BASE}/entries?path=${encodeURIComponent(path)}`
          : `/explore/${encodeURIComponent(bot)}?path=${encodeURIComponent(path)}`;
        const r = await fetch(url);
        if(!r.ok) throw new Error('explore failed');
        return await r.json();
      }
      async function apiReadFile(relPath){
        if(!REMOTE_MODE){
          socket.emit("readFile", { bot, path: relPath });
          return null;
        }
        const r = await fetch(`${NODE_API_BASE}/file?path=${encodeURIComponent(relPath)}`);
        if(!r.ok) throw new Error('read file failed');
        const j = await r.json();
        return j && typeof j.content === 'string' ? j.content : '';
      }
      async function apiWriteFile(relPath, content){
        if(!REMOTE_MODE){
          socket.emit("writeFile", { bot, path: relPath, content });
          return true;
        }
        const r = await fetch(`${NODE_API_BASE}/file`, {
          method:'POST', headers:{'Content-Type':'application/json'},
          body: JSON.stringify({ path: relPath, content })
        });
        if(!r.ok) throw new Error('write file failed');
        return true;
      }
      async function apiDelete(relPath, isDir){
        if(!REMOTE_MODE){
          socket.emit("deleteFile", { bot, path: relPath, isDir });
          return true;
        }
        const r = await fetch(`${NODE_API_BASE}/delete`, {
          method:'POST', headers:{'Content-Type':'application/json'},
          body: JSON.stringify({ path: relPath, isDir: !!isDir })
        });
        if(!r.ok) throw new Error('delete failed');
        return true;
      }
      async function apiRename(oldPath, newName){
        const url = REMOTE_MODE ? `${NODE_API_BASE}/rename` : '/rename';
        const payload = REMOTE_MODE
          ? { path: oldPath, newName }
          : { bot, oldPath, newName };
        const r = await fetch(url, {
          method:'POST', headers:{'Content-Type':'application/json'},
          body: JSON.stringify(payload)
        });
        if(!r.ok) throw new Error(await r.text().catch(()=>r.statusText));
        return true;
      }
      async function apiExtract(relPath){
        const url = REMOTE_MODE ? `${NODE_API_BASE}/extract` : '/extract';
        const payload = REMOTE_MODE ? { path: relPath } : { bot, path: relPath };
        const r = await fetch(url, {
          method:'POST', headers:{'Content-Type':'application/json'},
          body: JSON.stringify(payload)
        });
        const j = await r.json().catch(()=>({}));
        if(!r.ok || !j.ok) throw new Error((j && j.error) ? j.error : 'extract failed');
        return j;
      }
      function apiUploadWithProgress(file, currentPath, onProgress, baseMsg){
        return new Promise((resolve, reject)=>{
          const fd = new FormData();
          fd.append('file', file);
          if(!REMOTE_MODE){ fd.append('bot', bot); }
          fd.append('path', currentPath || '');

          const xhr = new XMLHttpRequest();
          xhr.open('POST', REMOTE_MODE ? `${NODE_API_BASE}/upload` : '/upload');
          xhr.upload.onprogress=(e)=>{ if(e.lengthComputable){ const pct=Math.round((e.loaded/e.total)*100); onProgress(pct, `${baseMsg} (${pct}%)`); } else onProgress(6, `${baseMsg}...`); };
          xhr.onload=()=>{ if(xhr.status>=200 && xhr.status<300){ try{ const j=JSON.parse(xhr.responseText||"{}"); onProgress(100, j && j.msg ? j.msg : "Finalizing..."); }catch{} resolve(); } else reject(new Error(xhr.responseText||xhr.statusText||('status '+xhr.status))); };
          xhr.onerror=()=>reject(new Error('Network error'));
          xhr.send(fd);
        });
      }
      async function apiCreate(type, name, currentPath){
        const url = REMOTE_MODE ? `${NODE_API_BASE}/create` : '/create';
        const payload = REMOTE_MODE
          ? { type, name, path: currentPath || '' }
          : { bot, type, name, path: currentPath || '' };
        const r = await fetch(url, {
          method:'POST', headers:{'Content-Type':'application/json'},
          body: JSON.stringify(payload)
        });
        if(!r.ok) throw new Error(await r.text().catch(()=>r.statusText));
        return true;
      }
      async function apiAction(data){
        if(!REMOTE_MODE){ socket.emit('action', data); return true; }
        const r = await fetch(`${NODE_API_BASE}/action`, {
          method:'POST', headers:{'Content-Type':'application/json'},
          body: JSON.stringify(data)
        });
        if(!r.ok) throw new Error(await r.text().catch(()=>r.statusText));
        return true;
      }
      async function apiCommand(command){
        if(!REMOTE_MODE){ socket.emit('command', { bot, command }); return true; }
        const r = await fetch(`${NODE_API_BASE}/command`, {
          method:'POST', headers:{'Content-Type':'application/json'},
          body: JSON.stringify({ command })
        });
        if(!r.ok) throw new Error(await r.text().catch(()=>r.statusText));
        return true;
      }

      // perms
      let IS_ADMIN = false;
      let PERMS = {
        files_read:false, files_delete:false, files_rename:false, console_write:false,
        server_stop:false, server_start:false, files_upload:false, files_create:false
      };
      function hasPerm(k){ return IS_ADMIN || !!PERMS[k]; }

      const consoleEl = document.getElementById("console");
      let consoleContentEl = document.getElementById('consoleContent');
      if (!consoleContentEl) {
        consoleContentEl = document.createElement('div');
        consoleContentEl.id = 'consoleContent';
        consoleEl.appendChild(consoleContentEl);
      }

      const scriptSelect = document.getElementById("scriptSelect");
      const cmdRow = document.getElementById("cmdRow");
      const cmdInput = document.getElementById("cmdInput");
      const entriesEl = document.getElementById("entries");
      const breadcrumbs = document.getElementById("breadcrumbs");
      const filesModal = document.getElementById("filesModal");
      const filesModalClose = document.getElementById("filesModalClose");
      const fileUploadModal = document.getElementById("fileUploadModal");
      const uploadLabel = document.getElementById("uploadLabel");
      const newBtn = document.getElementById("newBtn");

      const taskModal = document.getElementById("taskModal");
      const taskModalClose = document.getElementById("taskModalClose");
      const taskStartupSelect = document.getElementById("taskStartupSelect");
      const saveStartupBtn = document.getElementById("saveStartupBtn");

      const statusLabel = document.getElementById("statusLabel");
      const editorModal = document.getElementById("editorModal");
      const editorModalClose = document.getElementById("editorModalClose");
      const editorPath = document.getElementById("editorPath");
      const codeArea = document.getElementById("codeArea");
      const textArea = document.getElementById("textArea");
      const editorSave = document.getElementById("editorSave");
      const editorDiscard = document.getElementById("editorDiscard");

      const progressWheel = document.getElementById("progressWheel");
      const progressFill = document.getElementById("progressFill");
      const progressPopup = document.getElementById("progressPopup");
      const popupPercent = document.getElementById("popupPercent");
      const popupBar = document.getElementById("popupBar");
      const popupMsg = document.getElementById("popupMsg");
      const popupTime = document.getElementById("popupTime");
      const popupClose = document.getElementById("popupClose");
      const dropOverlay = document.getElementById("dropOverlay");
      const dropTitle = document.getElementById("dropTitle");
      const dropSubtitle = document.getElementById("dropSubtitle");

      const infoModal = document.getElementById("infoModal");
      const infoModalClose = document.getElementById("infoModalClose");
      const infoIp = document.getElementById("infoIp");
      const infoPort = document.getElementById("infoPort");
      const infoAddress = document.getElementById("infoAddress");
      const copyAddressBtn = document.getElementById("copyAddressBtn");

      const filesBtn = document.getElementById("filesBtn");
      const taskBtn = document.getElementById("taskBtn");
      const runBtn = document.getElementById("runBtn");
      const stopBtn = document.getElementById("stopBtn");
      const miniRunBtn = document.getElementById("miniRunBtn");
      const miniStopBtn = document.getElementById("miniStopBtn");
      const storeBtn = document.getElementById("storeBtn");

      const storeModal = document.getElementById("storeModal");
      const storeModalClose = document.getElementById("storeModalClose");
      const storeContent = document.getElementById("storeContent");
      const storeTabs = document.getElementById("storeTabs");
      const storeTabVersions = document.getElementById("storeTabVersions");
      const storeTabPlugins = document.getElementById("storeTabPlugins");
      const storeSubtitle = document.getElementById("storeSubtitle");

      const dockFiles = document.getElementById("dockFiles");
      const dockTask = document.getElementById("dockTask");
      const dockRun = document.getElementById("dockRun");
      const dockStop = document.getElementById("dockStop");
      const dockNew = document.getElementById("dockNew");
      const dockStore = document.getElementById("dockStore");

      const mrPluginModal = document.getElementById("mrPluginModal");
      const mrPluginModalClose = document.getElementById("mrPluginModalClose");
      const mrPluginName = document.getElementById("mrPluginName");
      const mrPlatformGrid = document.getElementById("mrPlatformGrid"); // kept for compatibility (unused in new UI)
      const mrVersionGrid = document.getElementById("mrVersionGrid");   // kept for compatibility (unused in new UI)
      const mrPluginInstallBtn = document.getElementById("mrPluginInstallBtn");

      let currentEditorPath = "";

      let serverInfo = null;
      let SERVER_NODE_ID = null;

      let currentStoreTab = 'versions';
      let storeProvidersCache = null;
      let storeCurrentProvider = null;

      let papermcVersionsCache = null;

      const JUMP_THRESHOLD = 8;

      // Modrinth plugins state
      const MR_VALID_LOADERS = ["paper","spigot","bukkit","purpur"];
      let mrPluginsState = {
        offset: 0,
        limit: 24,
        query: "",
        loading: false,
        more: true
      };
      let mrAllProjectVersions = [];
      let mrCurrentProjectId = null;
      let mrSelectedPlatform = null;
      let mrSelectedMcVersion = null;

      window.addEventListener('load', () => {
        ensureJumpBtn();
        updateJumpBtnVisibility();
      });
      window.addEventListener('resize', updateJumpBtnVisibility);

      async function fetchPerms(){
        try{
          const r = await fetch(`/api/servers/${encodeURIComponent(bot)}/permissions`);
          if(!r.ok) throw new Error('perm fetch failed');
          const j = await r.json();
          IS_ADMIN = !!j.isAdmin;
          if (j && j.perms && typeof j.perms === 'object') PERMS = Object.assign(PERMS, j.perms);
        } catch(e){
          IS_ADMIN = true;
          PERMS = {
            files_read:true, files_delete:true, files_rename:true, console_write:true,
            server_stop:true, server_start:true, files_upload:true, files_create:true
          };
        }
      }

      function clientClean(raw) {
        if (!raw) return "";
        let s = String(raw);
        s = s.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
        s = s.replace(/\u001b\[[0-9;]*m/g, "");

        s = s.replace(/^\s*(?:stdout|stderr)\s*:\s*/gmi, "");

        const out = [];
        for (let line of s.split("\n")) {
          line = line.replace(/\s+$/, "");
          const t = line.trim();
          if (!t) continue;
          if (t.includes("Usage:  docker")) continue;
          if (t.includes("Run 'docker COMMAND --help'")) continue;
          if (t.includes("For more help on how to use Docker")) continue;
          if (/^\s*Container started\s*$/i.test(t)) continue;
          if (/^[0-9a-f]{64}(?:\s*Container started)?\s*$/i.test(t)) continue;
          if (/^\s*\[?waiting\]?\s+/i.test(t)) continue;
          if (/container\s+".*"\s+not\s+found\s+yet/i.test(t)) continue;
          if (/Error response from daemon:\s*No such container/i.test(t)) continue;
          if (/^\s*\[init\]\s/i.test(t)) continue;
          if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d+Z,?version=.*$/i.test(t)) continue;
          out.push(line);
        }
        let joined = out.join("\n");
        joined = joined
          .replace(/([^\n])(?=20\d{2}-\d{2}-\d{2}T)/g, "$1\n")
          .replace(/([^\n])(?=\[\d{2}:\d{2}:\d{2}\s(?:INFO|WARN|ERROR))/g, "$1\n")
          .replace(/([^\n])(?=Starting org\.bukkit\.craftbukkit\.Main)/g, "$1\n")
          .replace(/([^\n])(?=\*\*\* Warning)/g, "$1\n");
        joined = joined.replace(/\n{2,}/g, "\n");
        if (joined && !joined.endsWith("\n")) joined += "\n";
        return joined;
      }

      let userPinnedBottom = true;
      let suppressAutoScroll = false;

      function isNearBottom(el) {
        return (el.scrollHeight - el.scrollTop - el.clientHeight) < JUMP_THRESHOLD;
      }
      function canScroll(el){
        return el && (el.scrollHeight - el.clientHeight) > 2;
      }

      let jumpBtn = null;
      function ensureJumpBtn() {
        if (jumpBtn) return jumpBtn;
        try {
          if (getComputedStyle(consoleEl).position === 'static') {
            consoleEl.style.position = 'relative';
          }
        } catch {}
        jumpBtn = document.createElement('button');
        jumpBtn.type = 'button';
        jumpBtn.className = 'jump-btn';
        jumpBtn.setAttribute('aria-label', 'Jump to bottom');
        jumpBtn.innerHTML = '<i class="fa-solid fa-arrow-down"></i>';
        consoleEl.appendChild(jumpBtn);
        jumpBtn.addEventListener('click', () => {
          scrollConsoleToBottom(true);
          suppressAutoScroll = false;
          userPinnedBottom   = true;
          jumpBtn.classList.remove('show');
        });
        updateJumpBtnVisibility();
        return jumpBtn;
      }
      function updateJumpBtnVisibility(){
        const btn = ensureJumpBtn();
        const show = canScroll(consoleEl) && !isNearBottom(consoleEl);
        btn.classList.toggle('show', show);
      }
      function scrollConsoleToBottom(smooth = true){
        try{
          if (smooth && typeof consoleEl.scrollTo === 'function') {
            consoleEl.scrollTo({ top: consoleEl.scrollHeight, behavior: 'smooth' });
          } else {
            consoleEl.scrollTop = consoleEl.scrollHeight;
          }
          requestAnimationFrame(() => { consoleEl.scrollTop = consoleEl.scrollHeight; });
        }catch{}
      }

      function appendToConsole(rawChunk) {
        const cleaned = clientClean(rawChunk);
        if (!cleaned) return;
        const wasNearBottom = isNearBottom(consoleEl);
        consoleContentEl.textContent += cleaned;
        if (!suppressAutoScroll && wasNearBottom) {
          scrollConsoleToBottom(false);
        }
        updateJumpBtnVisibility();
      }

      consoleEl.addEventListener('scroll', () => {
        userPinnedBottom = isNearBottom(consoleEl);
        suppressAutoScroll = !userPinnedBottom;
        updateJumpBtnVisibility();
      });

      function applyPermissionsToUI(){
        if(!hasPerm('console_write')){ cmdRow.classList.add('hidden'); }
        if(!hasPerm('server_start')){ runBtn.classList.add('disabled'); miniRunBtn.classList.add('disabled'); dockRun.classList.add('disabled'); }
        if(!hasPerm('server_stop')){ stopBtn.classList.add('disabled'); miniStopBtn.classList.add('disabled'); dockStop.classList.add('disabled'); }
        if(!hasPerm('files_read')){ filesBtn.classList.add('disabled'); dockFiles.classList.add('disabled'); }
        if(!hasPerm('files_upload')){ uploadLabel.classList.add('hidden'); fileUploadModal.classList.add('hidden'); }
        if(!hasPerm('files_create')){ newBtn.classList.add('hidden'); dockNew.classList.add('disabled'); editorSave.classList.add('disabled'); }
        if(!hasPerm('server_start')){ taskBtn.classList.add('disabled'); dockTask.classList.add('disabled'); }
      }

      socket.emit("join", bot);
      socket.on("output", (data) => appendToConsole(data));
      socket.on("fileData", (d) => { openEditorModal(d.path, d.content); });

      async function loadServerInfo() {
        const [topoRes, srvRes] = await Promise.allSettled([
          topoInfo().catch(() => null),
          fetch(`/api/server-info/${encodeURIComponent(bot)}`)
            .then(r => (r.ok ? r.json() : null))
            .catch(() => null)
        ]);
        const topo = topoRes.status === 'fulfilled' ? topoRes.value : null;
        const srv  = srvRes.status === 'fulfilled'  ? srvRes.value  : null;
        REMOTE_MODE = !!(topo && topo.remote);
        NODE_ID     = (topo && topo.nodeId) || (srv && srv.nodeId) || null;
        const topoInfoObj = (topo && topo.info) ? topo.info : {};
        serverInfo = Object.assign({}, topoInfoObj, srv || {});
        updateStoreVisibility();
      }

      function formatAddress(ip, port){
        if (!ip) return "";
        const is6 = ip.includes(":") && !ip.includes(".");
        const host = is6 ? `[${ip}]` : ip;
        return port ? `${host}:${port}` : host;
      }

      async function nodeAction(cmd, options = {}) {
        if (!SERVER_NODE_ID) throw new Error('no remote node');
        const r = await fetch(`/api/nodes/${encodeURIComponent(SERVER_NODE_ID)}/server/action`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(Object.assign({ name: bot, cmd }, options))
        });
        const j = await r.json().catch(()=> ({}));
        if (!r.ok || (j && j.error)) {
          const msg = (j && (j.detail || j.error)) || `HTTP ${r.status}`;
          throw new Error(msg);
        }
        return j;
      }

      async function nodeCommand(command) {
        if (!SERVER_NODE_ID) throw new Error('no remote node');
        const r = await fetch(`/api/nodes/${encodeURIComponent(SERVER_NODE_ID)}/server/command`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name: bot, command })
        });
        const j = await r.json().catch(()=> ({}));
        if (!r.ok || (j && j.error)) {
          const msg = (j && (j.detail || j.error)) || `HTTP ${r.status}`;
          throw new Error(msg);
        }
        return j;
      }

      function normalizeTemplate(t){ return (t ?? '').toString().trim().toLowerCase(); }
      function updateStoreVisibility(){
        const btn  = document.getElementById('storeBtn');
        const dock = document.getElementById('dockStore');
        const tabs = document.getElementById('storeTabs');
        if (!btn && !dock) return;
        const t = serverInfo ? normalizeTemplate(serverInfo.template) : null;
        const shouldShow = !t || t === 'minecraft' || t === 'discord-bot';
        const allowPlugins = !t || t === 'minecraft';
        [btn, dock].forEach(el => { if (el) el.classList.toggle('hidden', !shouldShow); });
        if (tabs) tabs.classList.toggle('hidden', !shouldShow);
        if (storeTabPlugins) storeTabPlugins.classList.toggle('hidden', !allowPlugins);
        if (!allowPlugins && currentStoreTab === 'plugins') setActiveStoreTab('versions');
      }

      function setActiveStoreTab(tab){
        currentStoreTab = tab;
        if (storeTabVersions) storeTabVersions.classList.toggle('active', tab === 'versions');
        if (storeTabPlugins) storeTabPlugins.classList.toggle('active', tab === 'plugins');
        if (storeSubtitle){
          const tpl = serverInfo ? normalizeTemplate(serverInfo.template) : null;
          if (tab === 'versions') {
            storeSubtitle.textContent = (tpl === 'minecraft')
              ? 'Choose your core distribution and version.'
              : 'Choose the runtime/version for your bot container.';
          } else if (tpl === 'minecraft') {
            storeSubtitle.textContent = 'Browse and install plugins from Modrinth.';
          } else {
            storeSubtitle.textContent = '';
          }
        }
      }

      document.addEventListener('DOMContentLoaded', () => {
        updateStoreVisibility();
      });

      async function openStoreModal() {
        if (!storeModal) return;
        storeModal.classList.add('show');
        storeModal.style.display = 'flex';
        storeModal.setAttribute('aria-hidden', 'false');
        setActiveStoreTab('versions');
        storeContent.innerHTML = `<div class="store-loading">Loading providers...</div>`;
        try {
          const r = await fetch(`/api/servers/${encodeURIComponent(bot)}/versions`);
          if (!r.ok) {
            storeContent.innerHTML = `<div class="store-error">Failed to load providers (${r.status})</div>`;
            return;
          }
          const data = await r.json();
          const providers = Array.isArray(data.providers) ? data.providers : [];
          if (!providers.length) {
            storeContent.innerHTML = '<div class="store-empty">No providers configured for this template.</div>';
            return;
          }
          await renderStoreProvidersView(providers);
        } catch (e) {
          storeContent.innerHTML = `<div class="store-error">Failed to load providers</div>`;
        }
      }

      function closeStoreModal(){
        if (!storeModal) return;
        storeModal.classList.remove('show');
        storeModal.style.display='none';
        storeModal.setAttribute('aria-hidden','true');
        storeCurrentProvider = null;
      }

      function compareMcVersionsDesc(a, b){
        const pa = String(a).split('.').map(x => parseInt(x, 10) || 0);
        const pb = String(b).split('.').map(x => parseInt(x, 10) || 0);
        const len = Math.max(pa.length, pb.length);
        for (let i = 0; i < len; i++){
          const va = typeof pa[i] === 'number' ? pa[i] : 0;
          const vb = typeof pb[i] === 'number' ? pb[i] : 0;
          if (va !== vb) return vb - va;
        }
        return 0;
      }

// Vanilla (Mojang) — manifest oficial: piston-meta.mojang.com
// Returnează { versions: [{ id,name,label,mcVersion,releaseDate,tags,downloadUrl }] }
async function fetchVanillaVersions({ includeSnapshots = false, limit = 200 } = {}) {
  const MANIFEST = 'https://piston-meta.mojang.com/mc/game/version_manifest_v2.json';
  let manifest;
  try {
    const r = await fetch(MANIFEST);
    if (!r.ok) throw new Error('manifest not ok');
    manifest = await r.json();
  } catch (e) {
    return { versions: [] };
  }

  const latestReleaseId  = manifest?.latest?.release || null;
  const latestSnapshotId = manifest?.latest?.snapshot || null;

  let list = Array.isArray(manifest?.versions) ? manifest.versions.slice() : [];
  // filtrează după tip (release vs snapshot)
  list = list.filter(v => includeSnapshots ? true : String(v.type) === 'release');
  // sortare desc după data de release
  list.sort((a, b) => new Date(b.releaseTime || b.time || 0) - new Date(a.releaseTime || a.time || 0));
  if (limit && Number.isFinite(limit)) list = list.slice(0, limit);

  // fetch în paralel manifesturile per-versiune ca să extragem server.jar
  const results = [];
  const concurrency = Math.min(8, Math.max(1, list.length));
  let idx = 0;

  async function worker() {
    while (idx < list.length) {
      const i = idx++;
      const v = list[i];
      try {
        const res = await fetch(v.url);
        if (!res.ok) continue;
        const verMeta = await res.json();
        const server = verMeta?.downloads?.server;
        if (!server?.url) continue; // unele snapshot-uri vechi nu au server.jar
        const mc = String(v.id);
        const date = String(v.releaseTime || v.time || '').split('T')[0] || '';
        const tags = [];
        if (String(v.type) === 'snapshot') tags.push('snapshot'); else tags.push('release');
        if (mc === latestReleaseId)  tags.push('latest');
        if (mc === latestSnapshotId) tags.push('latest-snapshot');

        results.push({
          id: mc,
          name: mc,
          label: `Vanilla ${mc}`,
          mcVersion: mc,
          releaseDate: date,
          tags,
          downloadUrl: server.url // de forma: https://piston-data.mojang.com/v1/objects/<sha1>/server.jar
        });
      } catch {
        /* noop */
      }
    }
  }

  await Promise.all(Array.from({ length: concurrency }, worker));

  // ordonează după versiune (folosește helperul tău existent)
  try {
    results.sort((a, b) => compareMcVersionsDesc(a.mcVersion, b.mcVersion));
  } catch {
    results.sort((a, b) => (b.releaseDate > a.releaseDate ? 1 : -1));
  }

  return { versions: results };
}

async function fetchWithTimeout(url, opts = {}, ms = 8000) {
  const ctrl = new AbortController();
  const id = setTimeout(() => ctrl.abort(), ms);
  try {
    return await fetch(url, { ...opts, signal: ctrl.signal });
  } finally {
    clearTimeout(id);
  }
}

function compareSemverDesc(a, b) {
  const pa = a.split('.').map(n => parseInt(n, 10) || 0);
  const pb = b.split('.').map(n => parseInt(n, 10) || 0);
  for (let i = 0; i < Math.max(pa.length, pb.length); i++) {
    const da = pa[i] ?? 0, db = pb[i] ?? 0;
    if (da !== db) return db - da;
  }
  return 0;
}

// Heuristică: 21.1.13 -> 1.21.1 (doar pentru label)
function neoForgeToMcVersion(ver) {
  const m = ver.match(/^(\d+)\.(\d+)\.(\d+)$/);
  if (!m) return '';
  const major = Number(m[1]); // 21 -> 1.21
  const minor = Number(m[2]); // 1  -> .1
  return `1.${major}.${minor}`;
}

// (OPȚIONAL) completează releaseDate cu Last-Modified, dar cu pool + timeout.
// Poți să NU o chemi dacă vrei fast-loading 100%.
async function addLastModifiedDates(list, urlFn, pool = 6, timeout = 5000) {
  let idx = 0;
  const workers = [];
  async function worker() {
    while (idx < list.length) {
      const i = idx++;
      const u = urlFn(list[i]);
      try {
        const r = await fetchWithTimeout(u, { method: 'HEAD' }, timeout);
        const lm = r.headers.get('last-modified');
        if (lm) list[i].releaseDate = new Date(lm).toISOString().slice(0, 10);
      } catch (_) { /* ignoră timeout/CORS */ }
    }
  }
  for (let i = 0; i < pool; i++) workers.push(worker());
  await Promise.all(workers);
}
      async function fetchPapermcVersions(){
        if (papermcVersionsCache) return papermcVersionsCache;
        const base = 'https://api.papermc.io/v2/projects/paper';
        let proj;
        try{
          const projRes = await fetch(base);
          if (!projRes.ok) throw new Error('Failed to load Paper project');
          proj = await projRes.json().catch(() => ({}));
        } catch(e){
          papermcVersionsCache = { versions: [] };
          return papermcVersionsCache;
        }
        let versions = Array.isArray(proj.versions) ? proj.versions.slice() : [];
        if (!versions.length){
          papermcVersionsCache = { versions: [] };
          return papermcVersionsCache;
        }
        versions.sort(compareMcVersionsDesc);
        const results = [];
        const concurrency = 8;
        let idx = 0;
        async function worker(){
          while (idx < versions.length){
            const i = idx++;
            const ver = versions[i];
            try{
              const verRes = await fetch(`${base}/versions/${encodeURIComponent(ver)}`);
              if (!verRes.ok) continue;
              const verData = await verRes.json().catch(() => ({}));
              const builds = Array.isArray(verData.builds) ? verData.builds : [];
              if (!builds.length) continue;
              const lastBuild = builds[builds.length - 1];
              let buildMeta = null;
              try{
                const buildRes = await fetch(`${base}/versions/${encodeURIComponent(ver)}/builds/${lastBuild}`);
                if (buildRes.ok){
                  buildMeta = await buildRes.json().catch(() => null);
                }
              }catch(_){}
              const jarName = `paper-${ver}-${lastBuild}.jar`;
              const downloadUrl = `${base}/versions/${encodeURIComponent(ver)}/builds/${lastBuild}/downloads/${encodeURIComponent(jarName)}`;
              const entry = {
                id: String(ver),
                name: String(ver),
                label: `Paper ${ver}`,
                mcVersion: String(ver),
                releaseDate: (buildMeta && typeof buildMeta.time === 'string')
                  ? buildMeta.time.split('T')[0]
                  : '',
                tags: [],
                build: lastBuild,
                downloadUrl
              };
              const tags = entry.tags;
              const channel = buildMeta && typeof buildMeta.channel === 'string'
                ? buildMeta.channel.toLowerCase()
                : '';
              if (channel){
                if (channel === 'default' || channel === 'stable'){
                  if (!tags.includes('stable')) tags.push('stable');
                } else {
                  if (!tags.includes('unstable')) tags.push('unstable');
                  if (!tags.includes(channel)) tags.push(channel);
                }
              } else {
                if (!tags.includes('stable')) tags.push('stable');
              }
              if (buildMeta && buildMeta.promoted){
                if (!tags.includes('recommended')) tags.push('recommended');
              }
              results.push(entry);
            }catch(e){}
          }
        }
        const workers = [];
        for (let i = 0; i < concurrency; i++){
          workers.push(worker());
        }
        await Promise.all(workers);
        results.sort((a, b) => compareMcVersionsDesc(a.mcVersion, b.mcVersion));
        if (results.length){
          const latestTags = results[0].tags || (results[0].tags = []);
          if (!latestTags.includes('latest')) latestTags.push('latest');
        }
        papermcVersionsCache = { versions: results };
        return papermcVersionsCache;
      }

      async function fetchVelocityVersions(){
  const base = 'https://api.papermc.io/v2/projects/velocity';
  let proj;
  try{
    const res = await fetch(base);
    if (!res.ok) throw new Error('Failed to load Velocity project');
    proj = await res.json().catch(() => ({}));
  } catch(e){
    return { versions: [] };
  }

  let versions = Array.isArray(proj.versions) ? proj.versions.slice() : [];
  if (!versions.length) return { versions: [] };

  // Velocity versiunile sunt semver (ex: 3.3.0); sortăm descendent
  versions.sort(compareMcVersionsDesc);

  const results = [];
  const concurrency = 8;
  let idx = 0;

  async function worker(){
    while (idx < versions.length){
      const i = idx++;
      const ver = versions[i];
      try{
        const verRes = await fetch(`${base}/versions/${encodeURIComponent(ver)}`);
        if (!verRes.ok) continue;
        const verData = await verRes.json().catch(() => ({}));
        const builds = Array.isArray(verData.builds) ? verData.builds : [];
        if (!builds.length) continue;

        const lastBuild = builds[builds.length - 1];

        // meta pentru build (luăm channel, time, downloads)
        let buildMeta = null;
        try{
          const buildRes = await fetch(`${base}/versions/${encodeURIComponent(ver)}/builds/${lastBuild}`);
          if (buildRes.ok){
            buildMeta = await buildRes.json().catch(() => null);
          }
        }catch(_){}

        // găsim numele .jar din "downloads"
        let fileName = null;
        if (buildMeta && buildMeta.downloads){
          if (Array.isArray(buildMeta.downloads)){
            const app = buildMeta.downloads.find(d => d && d.name && /\.jar$/i.test(d.name)) || buildMeta.downloads[0];
            fileName = app && app.name;
          } else if (buildMeta.downloads.application && buildMeta.downloads.application.name){
            fileName = buildMeta.downloads.application.name;
          }
        }
        if (!fileName) fileName = `velocity-${ver}-${lastBuild}.jar`;

        const downloadUrl = `${base}/versions/${encodeURIComponent(ver)}/builds/${lastBuild}/downloads/${encodeURIComponent(fileName)}`;

        const entry = {
          id: String(ver),
          name: String(ver),
          label: `Velocity ${ver}`,
          mcVersion: "", // e proxy, nu afișăm "MC ..."
          releaseDate: (buildMeta && typeof buildMeta.time === 'string') ? buildMeta.time.split('T')[0] : '',
          tags: [],
          build: lastBuild,
          downloadUrl
        };

        const tags = entry.tags;
        const channel = buildMeta && typeof buildMeta.channel === 'string' ? buildMeta.channel.toLowerCase() : '';
        if (channel){
          if (channel === 'default' || channel === 'stable') {
            if (!tags.includes('stable')) tags.push('stable');
          } else {
            if (!tags.includes('unstable')) tags.push('unstable');
            if (!tags.includes(channel)) tags.push(channel);
          }
        } else {
          if (!tags.includes('stable')) tags.push('stable');
        }
        if (buildMeta && buildMeta.promoted){ if (!tags.includes('recommended')) tags.push('recommended'); }

        results.push(entry);
      }catch(_){}
    }
  }

  const workers = [];
  for (let i = 0; i < concurrency; i++) workers.push(worker());
  await Promise.all(workers);

  // sortăm descendent după versiune
  results.sort((a, b) => compareMcVersionsDesc(a.name, b.name));
  if (results.length){
    const t = results[0].tags || (results[0].tags = []);
    if (!t.includes('latest')) t.push('latest');
  }
  return { versions: results };
}

      async function fetchPurpurVersions(){
        const base = 'https://api.purpurmc.org/v2/purpur';
        let proj;
        try {
          const res = await fetch(base);
          if (!res.ok) throw new Error('Failed to load Purpur project');
          proj = await res.json().catch(() => ({}));
        } catch(e){
          return { versions: [] };
        }
        let versions = Array.isArray(proj.versions) ? proj.versions.slice() : [];
        if (!versions.length) return { versions: [] };
        versions.sort(compareMcVersionsDesc);
        const results = [];
        for (const ver of versions){
          try {
            const latestRes = await fetch(`${base}/${encodeURIComponent(ver)}/latest`);
            if (!latestRes.ok) continue;
            const latest = await latestRes.json().catch(() => ({}));
            const build   = latest.build;
            const time    = latest.timestamp || latest.time || '';
            const date    = typeof time === 'string' ? time.split('T')[0] : '';
            const downloadUrl = `${base}/${encodeURIComponent(ver)}/${encodeURIComponent(build)}/download`;
            const entry = {
              id: String(ver),
              name: String(ver),
              label: `Purpur ${ver}`,
              mcVersion: String(ver),
              releaseDate: date,
              tags: ['stable'],
              build,
              downloadUrl
            };
            results.push(entry);
          } catch(e){}
        }
        if (results.length){
          const t = results[0].tags || (results[0].tags = []);
          if (!t.includes('latest')) t.push('latest');
        }
        return { versions: results };
      }
async function fetchLeavesVersions(){
  const base = 'https://api.github.com/repos/LeavesMC/Leaves/releases';
  const pages = [1, 2, 3, 4, 5];           // exact cum ai cerut
  const perPage = 990;
  const headers = { 'Accept': 'application/vnd.github+json' };

  // 1) Luăm toate paginile în paralel
  const chunks = await Promise.all(pages.map(async (p) => {
    try {
      const res = await fetch(`${base}?per_page=${perPage}&page=${p}`, { headers });
      if (!res.ok) return [];
      const arr = await res.json();
      return Array.isArray(arr) ? arr : [];
    } catch {
      return [];
    }
  }));

  // 2) Aplatizăm și sortăm descrescător după data publicării
  const all = chunks.flat().filter(x => x && !x.draft && !x.prerelease);
  all.sort((a, b) => {
    const da = new Date(a.published_at || a.created_at || 0).getTime();
    const db = new Date(b.published_at || b.created_at || 0).getTime();
    return db - da;
  });

  // 3) Extragem o singură intrare per versiune MC (ex. "1.21.8")
  const seen = new Set();
  const out = [];

  function extractMcVersionFromRelease(rel){
    // întâi din tag_name (ex: "1.21.8-138-9331167" -> "1.21.8")
    const t = String(rel.tag_name || rel.name || '');
    let m = t.match(/(\d+\.\d+(?:\.\d+)?)/);
    if (m) return m[1];

    // fallback: din numele assetului (ex: "leaves-1.21.8.jar")
    if (Array.isArray(rel.assets)) {
      for (const a of rel.assets) {
        const s = String(a.name || a.browser_download_url || '');
        const mm = s.match(/(\d+\.\d+(?:\.\d+)?)/);
        if (mm) return mm[1];
      }
    }
    return null;
  }

  function pickJarAsset(rel){
    if (!Array.isArray(rel.assets)) return { url: null, sha256: null };

    // preferă exact patternul "leaves-<mc>.jar", altfel orice .jar
    let pref = rel.assets.find(a => /\.jar$/i.test(a?.name || '') &&
                                   /leaves-\d+\.\d+(?:\.\d+)?\.jar$/i.test(a?.name || ''));
    if (!pref) pref = rel.assets.find(a => /\.jar$/i.test(a?.name || ''));

    if (!pref) return { url: null, sha256: null };

    let sha = null;
    if (typeof pref.digest === 'string' && pref.digest.startsWith('sha256:')) {
      sha = pref.digest.split(':')[1];
    }
    return { url: pref.browser_download_url || null, sha256: sha };
  }

  for (const rel of all) {
    const mc = extractMcVersionFromRelease(rel);
    if (!mc) continue;
    if (seen.has(mc)) continue; // deja am luat cel mai nou pentru versiunea asta

    const { url: downloadUrl, sha256 } = pickJarAsset(rel);
    const releaseDate = String(rel.published_at || rel.created_at || '').split('T')[0] || '';

    out.push({
      id: mc,                          // id = versiunea MC (consistent cu restul)
      name: mc,
      label: `Leaves ${mc}`,
      mcVersion: mc,
      releaseDate,
      tags: ['github'],
      downloadUrl,
      // câmpuri extra utile (nu afectează UI-ul tău dacă nu le folosești):
      tag: rel.tag_name || '',
      url: rel.html_url || '',
      sha256: sha256 || null
    });

    seen.add(mc);
  }

  // 4) Sortăm listele finale descrescător după versiunea MC (folosește comparatorul tău existent)
  out.sort((a, b) => compareMcVersionsDesc(a.mcVersion, b.mcVersion));

  // marchează "latest" pe prima intrare
  if (out.length) {
    const t = out[0].tags || (out[0].tags = []);
    if (!t.includes('latest')) t.push('latest');
  }

  return { versions: out };
}

// Fetch NeoForge (din Maven) -> { versions: [...] } în același format cu ceilalți provideri
async function fetchNeoForgeVersions() {
  const META_URL = 'https://maven.neoforged.net/releases/net/neoforged/neoforge/maven-metadata.xml';

  // 1) Ia toate versiunile din maven-metadata.xml
  const res = await fetch(META_URL);
  if (!res.ok) return { versions: [] };
  const xml = await res.text();
  const doc = new DOMParser().parseFromString(xml, 'application/xml');
  const versions = [...doc.querySelectorAll('versioning > versions > version')]
    .map(v => v.textContent.trim())
    .filter(Boolean)
    .sort(compareSemverDesc);

  // 2) Convertește versiunea NeoForge -> versiune MC (heuristică: 21.1.13 -> 1.21.1)
  function toMcVersion(neoforgeVer) {
    // format așteptat: MAJOR.MINOR.PATCH (ex: 21.1.13)
    const m = neoforgeVer.match(/^(\d+)\.(\d+)\.(\d+)$/);
    if (!m) return ''; // fallback
    const major = Number(m[1]); // 21 => MC 1.21
    const minor = Number(m[2]); // 1  => MC 1.21.1
    return `1.${major}.${minor}`;
  }

  // 3) Helper: Last-Modified (dacă CORS permite); altfel lăsăm string gol
  async function getLastModified(url) {
    try {
      const head = await fetch(url, { method: 'HEAD' });
      const lm = head.headers.get('last-modified');
      if (!lm) return '';
      const d = new Date(lm);
      if (isNaN(d.getTime())) return '';
      // doar YYYY-MM-DD
      return d.toISOString().slice(0, 10);
    } catch {
      return '';
    }
  }

  // 4) Construiește obiectele de versiune
  const out = [];
  for (const ver of versions) {
    const mcVersion = toMcVersion(ver);
    const base = `https://maven.neoforged.net/releases/net/neoforged/neoforge/${ver}/neoforge-${ver}`;
    const installerUrl = `${base}-installer.jar`;
    const universalUrl = `${base}-universal.jar`;

    const releaseDate = await getLastModified(installerUrl); // best-effort
    out.push({
      id: ver,
      name: ver,
      label: `NeoForge ${mcVersion || ver}`,
      mcVersion: mcVersion || '',
      releaseDate: releaseDate || '',
      tags: ['stable'],
      build: ver.split('.').pop() || '',
      // Pentru provisioning recomand installer-ul; universal îl las ca alternativă
      downloadUrl: installerUrl,
      altDownloads: { installer: installerUrl, universal: universalUrl }
    });
  }

  if (out[0] && !out[0].tags.includes('latest')) out[0].tags.push('latest');
  return { versions: out };

  // === helpers ===
  function compareSemverDesc(a, b) {
    const pa = a.split('.').map(n => parseInt(n, 10) || 0);
    const pb = b.split('.').map(n => parseInt(n, 10) || 0);
    for (let i = 0; i < Math.max(pa.length, pb.length); i++) {
      const da = pa[i] ?? 0, db = pb[i] ?? 0;
      if (da !== db) return db - da;
    }
    return 0;
  }
}

async function fetchSpigotVersions() {
  const BASE = "https://api.github.com/repos/BaldGang/spigot-build/releases?per_page=1";

  // Comparator desc pentru versiunile MC (1.21.10 > 1.21.8 > 1.21.1 etc.)
  function compareDesc(a, b) {
    const pa = String(a).split('.').map(n => parseInt(n, 10) || 0);
    const pb = String(b).split('.').map(n => parseInt(n, 10) || 0);
    const len = Math.max(pa.length, pb.length);
    for (let i = 0; i < len; i++) {
      const va = pa[i] ?? 0, vb = pb[i] ?? 0;
      if (va !== vb) return vb - va;
    }
    return 0;
  }
  const cmp = (typeof compareMcVersionsDesc === "function") ? compareMcVersionsDesc : compareDesc;

  try {
    const res = await fetch(BASE, {
      headers: { "Accept": "application/vnd.github+json" }
      // Dacă ai token GitHub pt. rate-limit mai mare:
      // headers: { "Accept": "application/vnd.github+json", "Authorization": `Bearer ${GITHUB_TOKEN}` }
    });
    if (!res.ok) throw new Error(`GitHub API ${res.status}`);
    const releases = await res.json();
    if (!Array.isArray(releases) || releases.length === 0) {
      return { versions: [] };
    }

    const rel = releases[0]; // doar ultimul release
    const assets = Array.isArray(rel.assets) ? rel.assets : [];

    // Dedupe pe versiune; dacă apar dubluri, păstrăm asset-ul cu data cea mai recentă
    const byVersion = new Map();

    for (const a of assets) {
      const name = a?.name ?? "";
      const m = name.match(/^spigot-(\d+\.\d+(?:\.\d+)?).jar$/i);
      if (!m || !a.browser_download_url) continue;

      const ver = m[1];
      const rawDate = a.updated_at || a.created_at || rel.published_at || rel.created_at || "";
      const dateOnly = String(rawDate).split("T")[0] || "";

      const candidate = {
        version: ver,
        url: a.browser_download_url,
        date: dateOnly,
        // pentru comparație internă folosim timestamp numeric
        _ts: Date.parse(a.updated_at || a.created_at || rel.published_at || rel.created_at || 0) || 0
      };

      const existing = byVersion.get(ver);
      if (!existing || candidate._ts > existing._ts) {
        byVersion.set(ver, candidate);
      }
    }

    if (byVersion.size === 0) {
      return { versions: [] };
    }

    // În array, sortat desc
    const candidates = Array.from(byVersion.values())
      .sort((x, y) => cmp(x.version, y.version));

    // Map în formatul tău
    const out = candidates.map((c) => ({
      id: c.version,
      name: c.version,
      label: `SpigotMC ${c.version}`,
      mcVersion: c.version,
      releaseDate: c.date,       // doar YYYY-MM-DD
      tags: ["stable"],
      build: null,
      downloadUrl: c.url
    }));

    // marchează primul ca latest
    out[0].tags = ["latest", "stable"];

    return { versions: out };
  } catch (e) {
    console.error("fetchSpigotVersions failed:", e);
    return { versions: [] };
  }
}
      async function fetchFoliaVersions(){
  const base = 'https://api.papermc.io/v2/projects/folia';

  // 1) proiectul + lista de versiuni
  let proj;
  try{
    const res = await fetch(base);
    if (!res.ok) throw new Error('Failed to load Folia project');
    proj = await res.json().catch(()=> ({}));
  }catch(e){
    return { versions: [] };
  }

  let versions = Array.isArray(proj.versions) ? proj.versions.slice() : [];
  if (!versions.length) return { versions: [] };
  versions.sort(compareMcVersionsDesc);

  // 2) pentru fiecare versiune: ultimul build + meta (pt. data / channel / numele fișierului)
  const out = [];
  const concurrency = 8;
  let idx = 0;

  async function worker(){
    while (idx < versions.length){
      const i = idx++;
      const ver = String(versions[i]);

      try{
        // a) lista de build-uri pt versiune
        const verRes = await fetch(`${base}/versions/${encodeURIComponent(ver)}`);
        if (!verRes.ok) continue;
        const verData = await verRes.json().catch(()=> ({}));
        const builds  = Array.isArray(verData.builds) ? verData.builds : [];
        if (!builds.length) continue;

        const lastBuild = builds[builds.length - 1];

        // b) meta pentru buildul ales
        let buildMeta = null;
        try{
          const bRes = await fetch(`${base}/versions/${encodeURIComponent(ver)}/builds/${lastBuild}`);
          if (bRes.ok) buildMeta = await bRes.json().catch(()=> null);
        }catch(_){}

        // c) aflăm numele corect al JAR-ului din meta (fallback sigur dacă lipsește)
        let jarName = null;
        if (buildMeta && buildMeta.downloads) {
          if (buildMeta.downloads.application && buildMeta.downloads.application.name) {
            jarName = buildMeta.downloads.application.name;
          } else if (Array.isArray(buildMeta.downloads)) {
            const anyJar = buildMeta.downloads.find(d => d && d.name && /\.jar$/i.test(d.name));
            if (anyJar) jarName = anyJar.name;
          }
        }
        if (!jarName) jarName = `folia-${ver}-${lastBuild}.jar`;

        const downloadUrl = `${base}/versions/${encodeURIComponent(ver)}/builds/${lastBuild}/downloads/${encodeURIComponent(jarName)}`;

        // d) obiectul de listă pt UI
        const date = (buildMeta && typeof buildMeta.time === 'string') ? buildMeta.time.split('T')[0] : '';
        const entry = {
          id: ver,
          name: ver,
          label: `Folia ${ver}`,
          mcVersion: ver,
          releaseDate: date,
          tags: [],
          build: lastBuild,
          downloadUrl
        };

        // e) tag-uri (stable/unstable/recommended/latest)
        const channel = buildMeta && typeof buildMeta.channel === 'string'
          ? buildMeta.channel.toLowerCase()
          : '';
        if (channel){
          if (channel === 'default' || channel === 'stable') entry.tags.push('stable');
          else entry.tags.push('unstable', channel);
        } else {
          entry.tags.push('stable');
        }
        if (buildMeta && buildMeta.promoted) entry.tags.push('recommended');

        out.push(entry);
      }catch(_){}
    }
  }

  const workers = [];
  for (let i = 0; i < concurrency; i++) workers.push(worker());
  await Promise.all(workers);

  // sort desc; marchează primul ca latest
  out.sort((a,b) => compareMcVersionsDesc(a.mcVersion || a.name, b.mcVersion || b.name));
  if (out.length){
    const t = out[0].tags || (out[0].tags = []);
    if (!t.includes('latest')) t.push('latest');
  }

  return { versions: out };
}

      async function fetchWaterfallVersions(){
  const base = 'https://api.papermc.io/v2/projects/waterfall';

  // 1) proiectul + lista de versiuni (ex: 1.20.4, 1.20.1 etc.)
  let proj;
  try{
    const res = await fetch(base);
    if (!res.ok) throw new Error('Failed to load Waterfall project');
    proj = await res.json().catch(()=> ({}));
  }catch(e){
    return { versions: [] };
  }

  let versions = Array.isArray(proj.versions) ? proj.versions.slice() : [];
  if (!versions.length) return { versions: [] };
  versions.sort(compareMcVersionsDesc);

  // 2) pentru fiecare versiune: ia ultimul build + meta (pentru data / channel / nume fișier corect)
  const out = [];
  const concurrency = 8;
  let idx = 0;

  async function worker(){
    while (idx < versions.length){
      const i = idx++;
      const ver = String(versions[i]);

      try{
        // a) lista de build-uri pt versiunea curentă
        const verRes = await fetch(`${base}/versions/${encodeURIComponent(ver)}`);
        if (!verRes.ok) continue;
        const verData = await verRes.json().catch(()=> ({}));
        const builds  = Array.isArray(verData.builds) ? verData.builds : [];
        if (!builds.length) continue;

        const lastBuild = builds[builds.length - 1];

        // b) meta pentru buildul ales
        let buildMeta = null;
        try{
          const bRes = await fetch(`${base}/versions/${encodeURIComponent(ver)}/builds/${lastBuild}`);
          if (bRes.ok) buildMeta = await bRes.json().catch(()=> null);
        }catch(_){}

        // c) află numele corect al JAR-ului
        let jarName = null;
        if (buildMeta && buildMeta.downloads) {
          if (buildMeta.downloads.application && buildMeta.downloads.application.name) {
            jarName = buildMeta.downloads.application.name;
          } else if (Array.isArray(buildMeta.downloads)) {
            const anyJar = buildMeta.downloads.find(d => d && d.name && /\.jar$/i.test(d.name));
            if (anyJar) jarName = anyJar.name;
          }
        }
        // fallback sigur (naming PaperMC). Waterfall folosește adesea "Waterfall-<ver>-<build>.jar"
        if (!jarName) jarName = `Waterfall-${ver}-${lastBuild}.jar`;

        const downloadUrl = `${base}/versions/${encodeURIComponent(ver)}/builds/${lastBuild}/downloads/${encodeURIComponent(jarName)}`;

        // d) construim obiectul de listă
        const date = (buildMeta && typeof buildMeta.time === 'string') ? buildMeta.time.split('T')[0] : '';
        const entry = {
          id: ver,
          name: ver,
          label: `Waterfall ${ver}`,
          mcVersion: ver,           // pentru proxy punem versiunea MC aici ca să o vezi în UI
          releaseDate: date,
          tags: [],
          build: lastBuild,
          downloadUrl
        };

        // e) tag-uri (stable/unstable/recommended/latest)
        const channel = buildMeta && typeof buildMeta.channel === 'string'
          ? buildMeta.channel.toLowerCase()
          : '';
        if (channel){
          if (channel === 'default' || channel === 'stable') entry.tags.push('stable');
          else entry.tags.push('unstable', channel);
        } else {
          entry.tags.push('stable');
        }
        if (buildMeta && buildMeta.promoted) entry.tags.push('recommended');

        out.push(entry);
      }catch(_){}
    }
  }

  const workers = [];
  for (let i = 0; i < concurrency; i++) workers.push(worker());
  await Promise.all(workers);

  // sort desc după versiune (dotted numbers)
  out.sort((a,b) => compareMcVersionsDesc(a.mcVersion || a.name, b.mcVersion || b.name));
  if (out.length){
    const t = out[0].tags || (out[0].tags = []);
    if (!t.includes('latest')) t.push('latest');
  }

  return { versions: out };
}

      async function fetchStoreProviders(){
        const res = await fetch(`/api/servers/${encodeURIComponent(bot)}/versions`);
        if (!res.ok) throw new Error('Failed to load providers');
        const j = await res.json();
        storeProvidersCache = j.providers || [];
        return j;
      }

async function fetchStoreVersions(providerId){
  const pid = (providerId || '').toString().toLowerCase();
  
  if (pid.includes('vanilla'))  return await fetchVanillaVersions();
  if (pid.includes('paper'))   return await fetchPapermcVersions();
  if (pid.includes('purpur'))  return await fetchPurpurVersions();
  if (pid.includes('velocity'))return await fetchVelocityVersions(); // <— ADĂUGAT
  if (pid.includes('waterfall'))return await fetchWaterfallVersions();
  if (pid.includes('folia'))  return await fetchFoliaVersions();
  if (pid.includes('leaves'))  return await fetchLeavesVersions();
  if (pid.includes('spigot'))  return await fetchSpigotVersions();

  // fallback la backend custom (dacă ai alți provideri în versions.json)
  const res = await fetch(`/api/servers/${encodeURIComponent(bot)}/versions/${encodeURIComponent(providerId)}`);
  if (!res.ok) throw new Error('Failed to load provider versions');
  return await res.json();
}

      async function renderStoreProvidersView(providersFromServer = null){
        if (!storeContent) return;
        setActiveStoreTab('versions');
        storeCurrentProvider = null;
        storeContent.innerHTML = '<div class="store-loading">Loading providers...</div>';
        try{
          const providers = providersFromServer || (await fetchStoreProviders(), storeProvidersCache);
          if (!providers || providers.length === 0){
            storeContent.innerHTML = '<div class="store-empty">No providers configured in versions.json.</div>';
            return;
          }
          const grid = document.createElement('div');
          grid.className = 'store-content-grid';
          providers.forEach(p => {
            const card = document.createElement('button');
            card.className = 'store-provider-card';
            card.type = 'button';
            card.addEventListener('click', ()=> openProviderDetails(p));
            const logoWrap = document.createElement('div');
            logoWrap.className = 'store-provider-logo';
            if (p.logo){
              const img = document.createElement('img');
              img.src = p.logo;
              img.alt = p.name || p.id || '';
              logoWrap.appendChild(img);
            } else {
              const span = document.createElement('span');
              span.className = 'store-provider-logo-placeholder';
              span.textContent = (p.name || p.id || '?').slice(0,2).toUpperCase();
              logoWrap.appendChild(span);
            }
            const body = document.createElement('div');
            body.className = 'store-provider-body';
            const title = document.createElement('div');
            title.className = 'store-provider-name';
            title.textContent = p.name || p.id;
            const desc = document.createElement('div');
            desc.className = 'store-provider-desc';
            desc.textContent = p.description || '';
            body.appendChild(title);
            body.appendChild(desc);
            const chevron = document.createElement('div');
            chevron.className = 'store-provider-chevron';
            chevron.innerHTML = '<i class="fa-solid fa-chevron-right"></i>';
            card.appendChild(logoWrap);
            card.appendChild(body);
            card.appendChild(chevron);
            grid.appendChild(card);
          });
          storeContent.innerHTML = '';
          storeContent.appendChild(grid);
        } catch(err){
          storeContent.innerHTML = `<div class="store-error">Failed to load providers: ${err.message || err}</div>`;
        }
      }

      async function applyVersion(providerId, versionId, displayLabel, downloadUrl){
        if (!hasPerm('server_start') && !hasPerm('files_create')) { alert('Unauthorized'); return; }
        const label = displayLabel || versionId;
        if (!confirm(`Install "${label}" on "${bot}"?`)) return;
        showProgressWheel(3, `Applying ${label}...`);
        try{
          const payload = { providerId, versionId };
          if (downloadUrl) payload.url = downloadUrl;
          const r = await fetch(`/api/servers/${encodeURIComponent(bot)}/versions/apply`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });
          let j = null;
          try { j = await r.json(); } catch { j = null; }
          if (!r.ok || !j || !j.ok) {
            const msg = (j && (j.detail || j.error)) ? (j.detail || j.error) : `HTTP ${r.status}`;
            throw new Error(msg);
          }
          try { await loadServerInfo(); updateStoreVisibility(); } catch {}
        } catch(e){
          setProgress(0, 'Apply failed');
          alert('Apply failed: ' + (e && e.message ? e.message : e));
        } finally {
          setTimeout(hideProgressWheel, 450);
        }
      }
      window.applyVersion = applyVersion;

      async function openProviderDetails(provider){
        if (!storeContent) return;
        storeCurrentProvider = provider;
        storeContent.innerHTML = '<div class="store-loading">Loading versions...</div>';
        try{
          const data = await fetchStoreVersions(provider.id || provider.provider || '');
          const versions = data.versions || [];
          const wrapper = document.createElement('div');

          /* Header row with logo + text side by side */
          const header = document.createElement('div');
          header.className = 'store-provider-header';
          const left = document.createElement('div');
          left.className = 'store-provider-header-main';
          const logoWrap = document.createElement('div');
          logoWrap.className = 'store-provider-logo';
          if (provider.logo){
            const img = document.createElement('img');
            img.src = provider.logo;
            img.alt = provider.name || provider.id || '';
            img.className = 'store-provider-header-logo';
            logoWrap.appendChild(img);
          } else {
            const span = document.createElement('span');
            span.className = 'store-provider-logo-placeholder';
            span.textContent = (provider.name || provider.id || '?').slice(0,2).toUpperCase();
            logoWrap.appendChild(span);
          }
          const text = document.createElement('div');
          const nameEl = document.createElement('div');
          nameEl.className = 'store-provider-header-name';
          nameEl.textContent = provider.name || data.displayName || provider.id;
          const descEl = document.createElement('div');
          descEl.className = 'store-provider-header-desc';
          descEl.textContent = provider.description || data.description || '';
          text.appendChild(nameEl);
          text.appendChild(descEl);
          left.appendChild(logoWrap);
          left.appendChild(text);
          const backBtn = document.createElement('button');
          backBtn.type = 'button';
          backBtn.className = 'store-back-btn';
          backBtn.innerHTML = '<i class="fa-solid fa-arrow-left"></i> Back';
          backBtn.addEventListener('click', ()=> renderStoreProvidersView());
          header.appendChild(left);
          header.appendChild(backBtn);
          wrapper.appendChild(header);

          const note = document.createElement('div');
          note.className = 'store-note';
          note.textContent = 'NOTE: Click on a version to install it into the server (ONE-TAP)';
          wrapper.appendChild(note);

          if (!versions.length){
            const empty = document.createElement('div');
            empty.className = 'store-empty';
            empty.textContent = 'No versions defined for this provider.';
            wrapper.appendChild(empty);
          } else {
            const list = document.createElement('div');
            list.className = 'store-version-list';
            versions.forEach(v => {
              const row = document.createElement('div');
              row.className = 'store-version-row';
              const meta = document.createElement('div');
              meta.className = 'store-version-meta';
              const vn = document.createElement('div');
              vn.className = 'store-version-name';
              vn.textContent = v.label || v.name || v.id;
              const vs = document.createElement('div');
              vs.className = 'store-version-sub';
              const parts = [];
              if (v.mcVersion) parts.push(`MC ${v.mcVersion}`);
              if (v.releaseDate) parts.push(v.releaseDate);
              if (!parts.length && v.name) parts.push(String(v.name));
              const detail = parts.join(' • ');
              vs.textContent = detail || (v.description || '');
              meta.appendChild(vn);
              meta.appendChild(vs);
              const tags = document.createElement('div');
              tags.className = 'store-version-tags';
              (v.tags || []).forEach(tag => {
                if (!tag) return;
                const t = String(tag).toLowerCase();
                const pill = document.createElement('span');
                pill.className = 'pill ' + (t === 'latest' || t === 'recommended' ? 'pill-green' : 'pill-muted');
                pill.textContent = t.toUpperCase();
                tags.appendChild(pill);
              });
              row.appendChild(meta);
              row.appendChild(tags);
              row.addEventListener('click', () => {
                const id = v.id || v.name || v.version || '';
                const label = v.label || v.name || id;
                const downloadUrl = v.downloadUrl || v.url || null;
                applyVersion(provider.id || provider.provider || '', id, label, downloadUrl);
              });
              list.appendChild(row);
            });
            wrapper.appendChild(list);
          }
          storeContent.innerHTML = '';
          storeContent.appendChild(wrapper);
        } catch(err){
          storeContent.innerHTML = `<div class="store-error">Failed to load versions: ${err.message || err}</div>`;
        }
      }

      function renderPluginsPlaceholder(){
        if (!storeContent) return;
        setActiveStoreTab('plugins');
        storeContent.innerHTML = '<div class="store-placeholder"><strong>Plugins</strong> management UI will live here.</div>';
      }

      // === Modrinth Plugins UI ===
      function renderPluginsUI(){
        if (!storeContent) return;
        setActiveStoreTab('plugins');
        storeContent.innerHTML = `
          <div class="mr-plugins-root">
            <div class="mr-plugins-header">
              <input id="mrPluginSearch" type="text" placeholder="Search plugins on Modrinth..." />
              <button id="mrPluginReload" class="store-tab"><i class="fa-solid fa-rotate"></i>&nbsp;Refresh</button>
            </div>
            <div id="mrPluginGrid" class="mr-plugin-grid"></div>
            <button id="mrPluginLoadMore" class="store-tab" style="margin-top:10px;align-self:flex-start;"><i class="fa-solid fa-angles-down"></i>&nbsp;Load more</button>
          </div>
        `;
        const searchInput = document.getElementById("mrPluginSearch");
        const reloadBtn = document.getElementById("mrPluginReload");
        const loadMoreBtn = document.getElementById("mrPluginLoadMore");
        mrPluginsState.offset = 0;
        mrPluginsState.more = true;
        mrPluginsState.loading = false;
        mrPluginsState.query = "";
        let searchTimeout = null;
        searchInput.addEventListener("input", () => {
          const q = searchInput.value.trim();
          if (searchTimeout) clearTimeout(searchTimeout);
          searchTimeout = setTimeout(() => {
            mrPluginsState.query = q;
            loadModrinthPlugins(true);
          }, 400);
        });
        reloadBtn.addEventListener("click", () => {
          searchInput.value = "";
          mrPluginsState.query = "";
          loadModrinthPlugins(true);
        });
        loadMoreBtn.addEventListener("click", () => {
          loadModrinthPlugins(false);
        });
        loadModrinthPlugins(true);
      }

      async function loadModrinthPlugins(reset){
        const grid = document.getElementById("mrPluginGrid");
        const loadMoreBtn = document.getElementById("mrPluginLoadMore");
        if (!grid) return;
        if (mrPluginsState.loading) return;
        if (reset){
          mrPluginsState.offset = 0;
          mrPluginsState.more = true;
          grid.innerHTML = '<div class="store-loading">Loading plugins from Modrinth...</div>';
        } else if (!mrPluginsState.more){
          return;
        }
        mrPluginsState.loading = true;
        try{
          const facets = encodeURIComponent('[["project_type:plugin"]]');
          let url = `https://api.modrinth.com/v2/search?limit=${mrPluginsState.limit}&offset=${mrPluginsState.offset}&facets=${facets}`;
          if (mrPluginsState.query) url += `&query=${encodeURIComponent(mrPluginsState.query)}`;
          const res = await fetch(url);
          if (!res.ok){
            grid.innerHTML = `<div class="store-error">Failed to load plugins (${res.status})</div>`;
            mrPluginsState.loading = false;
            return;
          }
          const data = await res.json();
          const hits = Array.isArray(data.hits) ? data.hits : [];
          if (reset){
            grid.innerHTML = "";
          }
          if (!hits.length){
            if (mrPluginsState.offset === 0){
              grid.innerHTML = '<div class="store-empty">No plugins found on Modrinth for this query.</div>';
            }
            mrPluginsState.more = false;
            if (loadMoreBtn) loadMoreBtn.style.display = "none";
          } else {
            hits.forEach(renderModrinthCard);
            mrPluginsState.offset += hits.length;
            if (loadMoreBtn) loadMoreBtn.style.display = (hits.length < mrPluginsState.limit) ? "none" : "inline-flex";
          }
        } catch(e){
          grid.innerHTML = `<div class="store-error">Failed to load plugins.</div>`;
        } finally {
          mrPluginsState.loading = false;
        }
      }

      function renderModrinthCard(hit){
        const grid = document.getElementById("mrPluginGrid");
        if (!grid) return;
        const card = document.createElement("div");
        card.className = "mr-plugin-card";
        const icon = hit.icon_url || "https://via.placeholder.com/200x140?text=No+Image";
        const downloads = typeof hit.downloads === "number" ? hit.downloads : 0;
        const downloadsText = downloads.toLocaleString();
        card.innerHTML = `
          <img src="${icon}" class="mr-plugin-icon" alt="">
          <div class="mr-plugin-body">
            <div class="mr-plugin-title">${hit.title}</div>
            <div class="mr-plugin-desc">${(hit.description || "").slice(0, 90)}${(hit.description || "").length > 90 ? "..." : ""}</div>
          </div>
          <div class="mr-plugin-footer">
            <span class="pill pill-muted"><i class="fa-solid fa-download"></i>&nbsp;${downloadsText}</span>
            <button class="mr-plugin-install-btn">Install</button>
          </div>
        `;
        card.querySelector(".mr-plugin-install-btn").addEventListener("click", (ev) => {
          ev.stopPropagation();
          openModrinthPluginModal(hit.project_id, hit.title);
        });
        card.addEventListener("click", () => openModrinthPluginModal(hit.project_id, hit.title));
        grid.appendChild(card);
      }

      async function openModrinthPluginModal(projectId, name){
        mrCurrentProjectId = projectId;
        mrSelectedPlatform = null;
        mrSelectedMcVersion = null;
        mrPluginInstallBtn.disabled = true;
        mrPluginName.textContent = name;

        // Reset the new SELECT UI
        const platformSelect = document.getElementById("mrPlatformSelect");
        const versionSelect  = document.getElementById("mrVersionSelect");
        platformSelect.innerHTML = `<option value="" selected disabled>Select a platform</option>`;
        versionSelect.innerHTML  = `<option value="" selected disabled>Select a Minecraft version</option>`;

        try{
          const res = await fetch(`https://api.modrinth.com/v2/project/${encodeURIComponent(projectId)}/version`);
          if (!res.ok){
            // if failed, keep selects disabled
          } else {
            mrAllProjectVersions = await res.json();
            populateModrinthPlatforms(); // fill the platform select
          }
        } catch(e){
          // swallow; UI remains
        }
        mrPluginModal.classList.add("show");
        mrPluginModal.style.display = "flex";
        mrPluginModal.setAttribute("aria-hidden","false");
      }

      function closeModrinthPluginModal(){
        mrPluginModal.classList.remove("show");
        mrPluginModal.style.display = "none";
        mrPluginModal.setAttribute("aria-hidden","true");
        mrCurrentProjectId = null;
        mrAllProjectVersions = [];
        mrSelectedPlatform = null;
        mrSelectedMcVersion = null;
        // Reset selects
        const platformSelect = document.getElementById("mrPlatformSelect");
        const versionSelect  = document.getElementById("mrVersionSelect");
        if (platformSelect) platformSelect.innerHTML = `<option value="" selected disabled>Select a platform</option>`;
        if (versionSelect)  versionSelect.innerHTML  = `<option value="" selected disabled>Select a Minecraft version</option>`;
        mrPluginInstallBtn.disabled = true;
      }

      mrPluginModalClose.addEventListener("click", closeModrinthPluginModal);
      mrPluginModal.addEventListener("click", (e) => {
        if (e.target === mrPluginModal) closeModrinthPluginModal();
      });

      /* Reworked: use SELECTOR controls instead of clickable boxes */
      function populateModrinthPlatforms(){
        const platformSelect = document.getElementById("mrPlatformSelect");
        const versionSelect  = document.getElementById("mrVersionSelect");
        if (!platformSelect || !versionSelect) return;

        // Build loader set
        const loaderSet = new Set();
        (mrAllProjectVersions || []).forEach(v => {
          (v.loaders || []).forEach(l => {
            if (MR_VALID_LOADERS.includes(l)) loaderSet.add(l);
          });
        });

        platformSelect.innerHTML = `<option value="" selected disabled>Select a platform</option>`;
        versionSelect.innerHTML  = `<option value="" selected disabled>Select a Minecraft version</option>`;
        mrSelectedPlatform = null;
        mrSelectedMcVersion = null;
        mrPluginInstallBtn.disabled = true;

        if (!loaderSet.size){
          // No valid loaders: leave select with only placeholder
          return;
        }
        Array.from(loaderSet).sort().forEach(loader => {
          const opt = document.createElement('option');
          opt.value = loader;
          opt.textContent = loader.toUpperCase();
          platformSelect.appendChild(opt);
        });

        platformSelect.onchange = () => {
          mrSelectedPlatform = platformSelect.value || null;
          mrSelectedMcVersion = null;
          mrPluginInstallBtn.disabled = true;
          populateModrinthVersions(); // fill versions for selected platform
        };
        versionSelect.onchange = () => {
          mrSelectedMcVersion = versionSelect.value || null;
          mrPluginInstallBtn.disabled = !(mrSelectedPlatform && mrSelectedMcVersion);
        };
      }

      function populateModrinthVersions(){
        const versionSelect  = document.getElementById("mrVersionSelect");
        if (!versionSelect) return;

        versionSelect.innerHTML = `<option value="" selected disabled>Select a Minecraft version</option>`;

        const versionsSet = new Set();
        (mrAllProjectVersions || []).forEach(v => {
          if (!v.loaders || !v.game_versions) return;
          if (!v.loaders.includes(mrSelectedPlatform)) return;
          v.game_versions.forEach(gv => {
            const match = String(gv).match(/^(\d+\.\d+(\.\d+)?)$/);
            if (match) versionsSet.add(match[1]);
          });
        });
        const list = Array.from(versionsSet).sort(compareMcVersionsDesc);
        list.forEach(ver => {
          const opt = document.createElement('option');
          opt.value = ver;
          opt.textContent = ver;
          versionSelect.appendChild(opt);
        });
      }

      mrPluginInstallBtn.addEventListener("click", async () => {
        if (!mrCurrentProjectId || !mrSelectedPlatform || !mrSelectedMcVersion) return;
        const match = (mrAllProjectVersions || []).find(v =>
          v.loaders && v.game_versions &&
          v.loaders.includes(mrSelectedPlatform) &&
          v.game_versions.includes(mrSelectedMcVersion)
        );
        if (!match){
          alert("No matching Modrinth version found for this platform / Minecraft version.");
          return;
        }
        const files = match.files || [];
        const file = files.find(f => f.primary) || files[0];
        if (!file || !file.url){
          alert("This Modrinth version does not expose a downloadable file.");
          return;
        }
        const label = `${mrPluginName.textContent} (${mrSelectedPlatform.toUpperCase()} ${mrSelectedMcVersion})`;
        try{
          await applyVersion("modrinth-plugin", match.id || `${mrCurrentProjectId}-${mrSelectedPlatform}-${mrSelectedMcVersion}`, label, file.url);
          alert("Plugin successfullly");
          closeModrinthPluginModal();
        } catch(e){
          alert("Failed to trigger plugin install: " + (e && e.message ? e.message : e));
        }
      });

      async function openInfoModal(){
        if (!serverInfo) await loadServerInfo();
        const ip = serverInfo && serverInfo.ip ? serverInfo.ip : "—";
        const port = (serverInfo && (serverInfo.port!==undefined && serverInfo.port!==null)) ? serverInfo.port : "—";
        infoIp.textContent = ip; infoPort.textContent = String(port);
        infoAddress.value = (ip!=="—") ? formatAddress(ip, (port!=="—") ? port : undefined) : "";
        infoModal.classList.add('show'); infoModal.style.display='flex'; infoModal.setAttribute('aria-hidden','false'); infoAddress.select();
      }
      function closeInfoModal(){ infoModal.classList.remove('show'); infoModal.style.display='none'; infoModal.setAttribute('aria-hidden','true'); }
      infoModalClose.addEventListener('click', closeInfoModal);
      copyAddressBtn.addEventListener('click', async () => {
        try{ if (!infoAddress.value) return; await navigator.clipboard.writeText(infoAddress.value);
          copyAddressBtn.innerHTML = '<i class="fa-solid fa-check"></i>&nbsp;Copied';
          setTimeout(()=> copyAddressBtn.innerHTML = '<i class="fa-solid fa-copy"></i>&nbsp;Copy', 1200);
        } catch(e){ infoAddress.select(); document.execCommand('copy'); }
      });

      if (storeModalClose) storeModalClose.addEventListener('click', closeStoreModal);
      if (storeTabVersions) storeTabVersions.addEventListener('click', ()=> {
        renderStoreProvidersView();
      });
      if (storeTabPlugins) storeTabPlugins.addEventListener('click', ()=> {
        renderPluginsUI();
      });

      function focusConsole(){ openInfoModal(); }

      function applyPreferredStartup(scripts){
        const saved = localStorage.getItem(`startup-${bot}`) || "";
        const startFromIndex = serverInfo && serverInfo.start ? String(serverInfo.start) : "";
        let preferred = saved || startFromIndex || "";
        if (!preferred && scripts.includes("server.jar")) preferred = "server.jar";
        if (preferred && scripts.includes(preferred)) {
          const a=[...scriptSelect.options].find(o=>o.value===preferred); if(a) scriptSelect.value=preferred;
          const b=[...taskStartupSelect.options].find(o=>o.value===preferred); if(b) taskStartupSelect.value=preferred;
        }
      }

      let currentPath = "";
      async function loadExplorer(path = ""){
        try{
          if (!hasPerm('files_read')) { entriesEl.innerHTML = `<li style="color:var(--muted)">Unauthorized</li>`; return; }
          const data = await apiExplore(path);
          currentPath = data.path || "";
          breadcrumbs.innerHTML = `<a href="#" onclick="loadExplorer('')">Root</a>${currentPath ? " / " + currentPath : ""}`;
          entriesEl.innerHTML = "";
          data.entries.forEach((e) => {
            const li = document.createElement("li"); li.className = "entry";
            const left = document.createElement("div"); left.className = "entry-left";
            const icon = document.createElement("div"); icon.className = `entry-icon ${e.isDir ? 'folder' : 'file'}`; icon.innerHTML = e.isDir ? '<i class="fa-solid fa-folder"></i>' : '<i class="fa-solid fa-file"></i>';
            const nameWrap = document.createElement("div");
            const nm = document.createElement("div"); nm.className = "entry-name"; nm.textContent = e.name;
            const meta = document.createElement("div"); meta.className = "entry-meta"; meta.textContent = e.isDir ? "Folder" : "File";
            nameWrap.appendChild(nm); nameWrap.appendChild(meta);
            left.appendChild(icon); left.appendChild(nameWrap);
            const actions = document.createElement("div"); actions.className = "entry-actions";
            const moreBtn = document.createElement("button"); moreBtn.className = "more-btn"; moreBtn.innerHTML = '<i class="fa-solid fa-ellipsis-vertical"></i>';
            const menu = document.createElement("div"); menu.className = "more-menu";
            if (hasPerm('files_rename')) {
              const renameBtn = document.createElement("button"); renameBtn.textContent = "Rename";
              renameBtn.addEventListener('click', async (ev) => {
                ev.stopPropagation();
                const newName = prompt(`Rename "${e.name}" to:`); if (!newName || !newName.trim()) return alert("Invalid name");
                try{
                  const oldPath = currentPath ? currentPath + "/" + e.name : e.name;
                  await apiRename(oldPath, newName.trim());
                  alert('Renamed'); loadExplorer(currentPath);
                }catch(err){ alert('Rename failed: ' + (err.message || err)); }
                finally{ menu.classList.remove('show'); }
              });
              menu.appendChild(renameBtn);
            }
            if (hasPerm('files_delete')) {
              const deleteBtn = document.createElement("button"); deleteBtn.textContent = "Delete";
              deleteBtn.addEventListener('click', async (ev) => {
                ev.stopPropagation();
                if (!confirm(`Delete ${e.isDir ? "folder" : "file"} "${e.name}"?`)) { menu.classList.remove('show'); return; }
                try{
                  const rel = currentPath ? currentPath + "/" + e.name : e.name;
                  await apiDelete(rel, e.isDir);
                  setTimeout(()=> loadExplorer(currentPath), 200);
                }catch(err){ alert('Delete failed: ' + (err.message || err)); }
                menu.classList.remove('show');
              });
              menu.appendChild(deleteBtn);
            }
            const isArchive = !e.isDir && /\.(zip|tar|tgz|tar\.gz|tar\.bz2|bz2|rar|7z)$/i.test(e.name);
            if (isArchive && hasPerm('files_create')) {
              const unarchiveBtn = document.createElement("button"); unarchiveBtn.textContent = "Unarchive";
              unarchiveBtn.addEventListener('click', async (ev)=>{
                ev.stopPropagation(); menu.classList.remove('show');
                const targetRel = currentPath ? currentPath + "/" + e.name : e.name;
                if (!confirm(`Unarchive "${e.name}" into current folder?`)) return;
                showProgressWheel(6, "Unarchiving...");
                try{
                  const j = await apiExtract(targetRel);
                  setProgress(100, j.msg || 'Unarchive complete'); await new Promise(r => setTimeout(r, 250));
                  loadExplorer(currentPath); alert('Unarchive completed');
                }catch(err){ alert('Unarchive failed: ' + (err.message || err)); }
                finally{ hideProgressWheel(); }
              });
              menu.appendChild(unarchiveBtn);
            }
            actions.appendChild(moreBtn); actions.appendChild(menu);
            moreBtn.addEventListener('click', (ev) => {
              ev.stopPropagation();
              document.querySelectorAll('.more-menu.show').forEach(m=> { if (m !== menu) m.classList.remove('show'); });
              menu.classList.toggle('show');
            });
            li.addEventListener('click', async () => {
              if (e.isDir) {
                loadExplorer(currentPath ? currentPath + "/" + e.name : e.name);
              } else if (hasPerm('files_read')) {
                const rel = currentPath ? currentPath + "/" + e.name : e.name;
                if (REMOTE_MODE) {
                  try{
                    const content = await apiReadFile(rel);
                    if (content !== null) openEditorModal(rel, content);
                  } catch(err){ alert('Open failed: ' + (err.message || err)); }
                } else {
                  socket.emit("readFile", { bot, path: rel });
                }
              }
            });
            const arrow = document.createElement("div"); arrow.className = "entry-arrow"; arrow.innerHTML = '<i class="fa-solid fa-chevron-right"></i>';
            const right = document.createElement("div"); right.className = "entry-right"; right.appendChild(actions); right.appendChild(arrow);
            li.appendChild(left); li.appendChild(right); entriesEl.appendChild(li);
          });
          const scripts = data.entries.filter(e => !e.isDir).map(e => e.name);
          scriptSelect.innerHTML = scripts.map(s => `<option value="${s}">${s}</option>`).join("");
          taskStartupSelect.innerHTML = `<option value="">(none)</option>` + scripts.map(s => `<option value="${s}">${s}</option>`).join("");
          applyPreferredStartup(scripts);
        }catch(err){
          entriesEl.innerHTML = `<li style="color:var(--muted)">${hasPerm('files_read') ? 'Failed to load' : 'Unauthorized'}</li>`;
        }
      }

      let currentProgress=0, simInterval=null, isActiveOperation=false, operationStart=null;
      function showProgressWheel(initial=0,msg="Processing..."){ isActiveOperation=true; operationStart=Date.now(); progressWheel.classList.remove('hidden'); setProgress(initial,msg); }
      function hideProgressWheel(){ isActiveOperation=false; setTimeout(()=>{ progressWheel.classList.add('hidden'); setProgress(0); closeProgressPopup(); operationStart=null; popupTime.textContent="—"; },300); }
      function setProgress(percent,msg="Processing..."){
        if(typeof percent!=='number') percent=0; percent=Math.max(0,Math.min(100,Math.round(percent)));
        currentProgress=percent; progressFill.style.height=percent+"%"; popupPercent.textContent=percent+"%"; popupBar.style.width=percent+"%";
        if(msg) popupMsg.textContent=msg;
        if(operationStart){ const elapsed=Math.floor((Date.now()-operationStart)/1000); popupTime.textContent=`${elapsed}s elapsed`; } else popupTime.textContent="—";
        if(percent>=100 && isActiveOperation){ setTimeout(()=> hideProgressWheel(),450); }
      }
      function openProgressPopup(){ progressPopup.style.display="block"; progressPopup.setAttribute('aria-hidden','false'); popupPercent.textContent=currentProgress+"%"; popupBar.style.width=currentProgress+"%"; if(operationStart){ const elapsed=Math.floor((Date.now()-operationStart)/1000); popupTime.textContent=`${elapsed}s elapsed`; } else popupTime.textContent="—"; }
      function closeProgressPopup(){ progressPopup.style.display="none"; progressPopup.setAttribute('aria-hidden','true'); }
      progressWheel.addEventListener('click',()=>{ if(progressPopup.style.display==='block') closeProgressPopup(); else openProgressPopup(); });
      popupClose.addEventListener('click',()=> closeProgressPopup());

      function enableDropHandlers(){
        if (!hasPerm('files_upload')) return;
        const modalInner=document.querySelector('#filesModal .modal'); if(!modalInner) return;
        ['dragenter','dragover','dragleave','drop'].forEach(evt=>{ modalInner.addEventListener(evt,(e)=>e.preventDefault(),{passive:false}); });
        modalInner.addEventListener('dragenter', onDragEnter);
        modalInner.addEventListener('dragover', onDragOver);
        modalInner.addEventListener('dragleave', onDragLeave);
        modalInner.addEventListener('drop', onDrop);
      }
      function disableDropHandlers(){
        const modalInner=document.querySelector('#filesModal .modal'); if(!modalInner) return;
        modalInner.removeEventListener('dragenter', onDragEnter);
        modalInner.removeEventListener('dragover', onDragOver);
        modalInner.removeEventListener('dragleave', onDragLeave);
        modalInner.removeEventListener('drop', onDrop);
      }
      let dragCounter=0;
      function onDragEnter(e){ e.preventDefault(); dragCounter++; dropOverlay.classList.add('visible'); dropTitle.textContent="Drop files here to upload"; dropSubtitle.textContent="Release to upload to current folder"; }
      function onDragOver(e){ e.preventDefault(); e.dataTransfer.dropEffect='copy'; if(!dropOverlay.classList.contains('visible')) dropOverlay.classList.add('visible'); }
      function onDragLeave(e){ e.preventDefault(); dragCounter=Math.max(0,dragCounter-1); if(dragCounter===0) dropOverlay.classList.remove('visible'); }
      async function onDrop(e){ e.preventDefault(); dragCounter=0; dropOverlay.classList.remove('visible'); const items=e.dataTransfer.files; if(!items||items.length===0) return; if(!hasPerm('files_upload')) return alert('Unauthorized'); const files=Array.from(items); await uploadFilesSequential(files); }

      async function uploadFilesSequential(files){
        for(let i=0;i<files.length;i++){
          const file=files[i], idx=i+1, total=files.length, msgBase=`Uploading ${idx} of ${total} — ${file.name}`;
          try{
            await apiUploadWithProgress(file, currentPath, (percent,state)=> setProgress(percent, state || msgBase), msgBase);
            await new Promise(r=>setTimeout(r,150)); loadExplorer(currentPath);
          }catch(err){ alert(`Upload failed for ${file.name}: ${err.message||err}`); }
        }
        setTimeout(()=>{ hideProgressWheel(); },400);
        alert('Uploads completed');
      }

      function openEditorModal(path, content){
        currentEditorPath = path;
        editorModal.classList.add('show'); editorModal.style.display='flex'; document.getElementById('editorPath').textContent=path;
        const lower=path.toLowerCase();
        if(
          lower.endsWith('.js') ||
          lower.endsWith('.ts') ||
          lower.endsWith('.json') ||
          lower.endsWith('.yml') ||
          lower.endsWith('.yaml') ||
          lower.endsWith('.html') ||
          lower.endsWith('.htm') ||
          lower.endsWith('.css')
        ){
          textArea.style.display='none';
          codeArea.style.display='block';
          codeArea.innerHTML=highlightCode(content, path);
          codeArea.dataset.raw=content;
          placeCaretAtEnd(codeArea);
          codeArea.focus();
        }
        else {
          codeArea.style.display='none';
          textArea.style.display='block';
          textArea.value=content;
          textArea.dataset.original=content;
          textArea.focus();
        }
        if(!hasPerm('files_create')){ editorSave.classList.add('disabled'); }
      }
      function closeEditorModal(){ editorModal.classList.remove('show'); editorModal.style.display='none'; document.getElementById('editorPath').textContent=''; codeArea.innerHTML=''; textArea.value=''; currentEditorPath=""; }
      editorModalClose.addEventListener('click', closeEditorModal);
      editorDiscard.addEventListener('click', () => {
        if (textArea.style.display!=='none') textArea.value = textArea.dataset.original || '';
        else codeArea.innerHTML = highlightCode(codeArea.dataset.raw || '', currentEditorPath);
      });
      editorSave.addEventListener('click', async () => {
        if (!hasPerm('files_create')) return alert('Unauthorized');
        const path = document.getElementById('editorPath').textContent; if(!path) return alert('No file open');
        let contentToSave = (textArea.style.display!=='none') ? textArea.value : getTextFromContentEditable(codeArea);
        try{
          await apiWriteFile(path, contentToSave);
          setTimeout(()=> { loadExplorer(currentPath); alert('Saved'); closeEditorModal(); }, 150);
        }catch(err){ alert('Save failed: ' + (err.message || err)); }
      });

      function run(){
        if (!hasPerm('server_start')) return alert('Unauthorized');
        consoleContentEl.textContent='';
        const savedStartup=localStorage.getItem(`startup-${bot}`)||'';
        const fallback=(serverInfo&&serverInfo.start)?String(serverInfo.start):'';
        const selected=savedStartup||scriptSelect.value||fallback;
        if(!selected) return alert('No script selected to run');
        statusLabel.textContent='running'; const lower=selected.toLowerCase();
        const template = serverInfo ? normalizeTemplate(serverInfo.template) : null;
        if(template === 'discord-bot'){
          const runtime = (serverInfo && serverInfo.runtime) || {};
          const overrides={
            image: runtime.image || 'node',
            tag: runtime.tag || '20-alpine',
            command: runtime.command || `node /app/${selected}`,
            env: runtime.env || {},
            volumes: runtime.volumes || ['{BOT_DIR}:/app']
          };
          apiAction({ bot, cmd:'run', templateId:'discord-bot', docker: overrides })
            .catch(err=>alert('Run failed: ' + (err.message||err)));
          attachLogStreamIfRemote();
          return;
        }
        if(lower.endsWith('.jar')){
          const overrides={ ports:['25565:25565'], env:{EULA:'TRUE',TYPE:'CUSTOM',CUSTOM_SERVER:`/data/${selected}`}, volumes:['{BOT_DIR}:/data'], restart:'unless-stopped' };
          apiAction({ bot, cmd:'run', templateId:'minecraft', docker: overrides }).catch(err=>alert('Run failed: ' + (err.message||err)));
          attachLogStreamIfRemote();
          return;
        }
        apiAction({ bot, cmd:'run', file: selected }).catch(err=>alert('Run failed: ' + (err.message||err)));
        attachLogStreamIfRemote();
      }
      function stop(){
        if (!hasPerm('server_stop')) return alert('Unauthorized');
        statusLabel.textContent = 'stopping';
        apiAction({ bot, cmd:'stop' })
          .then(() => setTimeout(() => statusLabel.textContent = 'idle', 500))
          .catch(err => alert('Stop failed: ' + (err.message || err)));
      }

      fileUploadModal.addEventListener('change', () => {
        if(!hasPerm('files_upload')) return alert('Unauthorized');
        const f=fileUploadModal.files[0]; if(!f) return;
        showProgressWheel(0, `Uploading 1 of 1 — ${f.name}`);
        apiUploadWithProgress(f, currentPath, (percent,msg)=> setProgress(percent,msg),`Uploading 1 of 1 — ${f.name}`)
          .then(()=>{ loadExplorer(currentPath); setTimeout(()=>{ hideProgressWheel(); alert('Upload complete'); },350); })
          .catch((err)=>{ hideProgressWheel(); alert('Upload failed: '+(err&&err.message?err.message:'unknown')); })
          .finally(()=>{ fileUploadModal.value=''; });
      });

      async function createNew(){
        if(!hasPerm('files_create')) return alert('Unauthorized');
        const type=prompt("Type 'file' to create a file or 'folder' to create a folder:"); if(!type || (type!=='file'&&type!=='folder')) return alert('Invalid type.');
        const name=prompt(`Enter ${type} name:`); if(!name) return;
        showProgressWheel(4, type==='file' ? "Creating file..." : "Creating folder..."); startSimulatedProgress(4,88,420);
        try{
          await apiCreate(type, name, currentPath);
          setProgress(100, (type==='file' ? "File created" : "Folder created"));
          loadExplorer(currentPath);
          setTimeout(()=>{ hideProgressWheel(); alert((type==='file'?'File':'Folder')+' created successfully'); },350);
        }catch(err){
          hideProgressWheel(); alert(err.message||'Create failed');
        }
      }

      function sendCommand(){
        if(!hasPerm('console_write')) return alert('Unauthorized');
        const cmd=cmdInput.value.trim(); if(cmd==='') return;
        apiCommand(cmd).catch(err=> alert('Command failed: ' + (err.message||err)));
        cmdInput.value='';
      }
      cmdInput.addEventListener('keyup', (e)=>{ if(e.key==='Enter') sendCommand(); });
      function clearConsole(){ consoleContentEl.textContent=''; updateJumpBtnVisibility(); }

      function openFilesModal(){
        if (!hasPerm('files_read')) return alert('Unauthorized');
        filesModal.classList.add('show'); filesModal.style.display='flex'; loadExplorer(currentPath); enableDropHandlers();
      }
      function closeFilesModal(){ filesModal.classList.remove('show'); filesModal.style.display='none'; disableDropHandlers(); }
      filesModalClose.addEventListener('click', closeFilesModal);

      function openTaskModal(){ if(!hasPerm('server_start')) return alert('Unauthorized'); taskModal.classList.add('show'); taskModal.style.display='flex'; loadExplorer(currentPath); }
      function closeTaskModal(){ taskModal.classList.remove('show'); taskModal.style.display='none'; }
      taskModalClose.addEventListener('click', closeTaskModal);

      saveStartupBtn.addEventListener('click', ()=> {
        if(!hasPerm('server_start')) return alert('Unauthorized');
        const val = taskStartupSelect.value || '';
        if (val) { localStorage.setItem(`startup-${bot}`, val); alert('Startup file saved: ' + val); }
        else { localStorage.removeItem(`startup-${bot}`); alert('Startup file cleared'); }
      });

      document.addEventListener('keydown', (e)=> {
        if (e.key==='Escape') {
          if (editorModal && editorModal.classList.contains('show')) { closeEditorModal(); return; }
          if (filesModal && filesModal.classList.contains('show')) { closeFilesModal(); return; }
          if (taskModal && taskModal.classList.contains('show')) { closeTaskModal(); return; }
          if (infoModal && infoModal.classList.contains('show')) { closeInfoModal(); return; }
          if (storeModal && storeModal.classList.contains('show')) { closeStoreModal(); return; }
          if (mrPluginModal && mrPluginModal.classList.contains('show')) { closeModrinthPluginModal(); return; }
          if (progressPopup && progressPopup.style.display==='block') { closeProgressPopup(); return; }
        }
      });
      document.addEventListener('click', () => { document.querySelectorAll('.more-menu.show').forEach(m => m.classList.remove('show')); });

      document.addEventListener('DOMContentLoaded', async ()=>{
        await fetchPerms(); applyPermissionsToUI();
        await loadServerInfo();
        attachLogStreamIfRemote();
        await loadExplorer();
      });

      function escapeHtmlRaw(s){
        return String(s)
          .replace(/&/g,'&amp;')
          .replace(/</g,'&lt;')
          .replace(/>/g,'&gt;');
      }

      function detectLanguageFromPath(path){
        const lower = (path || '').toLowerCase();
        if (lower.endsWith('.yml') || lower.endsWith('.yaml')) return 'yaml';
        if (lower.endsWith('.json')) return 'json';
        if (lower.endsWith('.html') || lower.endsWith('.htm')) return 'html';
        if (lower.endsWith('.css')) return 'css';
        if (lower.endsWith('.ts')) return 'ts';
        if (lower.endsWith('.js')) return 'js';
        return 'plain';
      }

      function highlightCode(src, path){
        if(typeof src!=='string') src='';
        const lang = detectLanguageFromPath(path);
        let out = escapeHtmlRaw(src);
        if (lang === 'yaml'){
          out = out.replace(/(#.*)$/gm,'<span class="com">$1</span>');
          out = out.replace(/("([^"\\]|\\.)*"|'([^'\\]|\\.)*')/g,'<span class="str">$1</span>');
        } else if (lang === 'json'){
          out = out.replace(/"(\\.|[^"\\])*"/g,'<span class="str">$&</span>');
          out = out.replace(/\b(true|false|null)\b/g,'<span class="kw">$1</span>');
          out = out.replace(/\b(\d+(\.\d+)?)\b/g,'<span class="num">$1</span>');
        } else if (lang === 'html'){
          out = out.replace(/(<!--[\s\S]*?-->)/g,'<span class="com">$1</span>');
          out = out.replace(/(&lt;\/?)([a-zA-Z0-9\-]+)([^&gt;]*?)(&gt;)/g,(m, open, tag, attrs, close)=>{
            attrs = attrs.replace(/([a-zA-Z0-9\-:]+)=(".*?"|'.*?')/g,'<span class="attr">$1</span>=<span class="str">$2</span>');
            return '<span class="tag">'+open+tag+attrs+close+'</span>';
          });
        } else if (lang === 'css'){
          out = out.replace(/(\/\*[\s\S]*?\*\/)/g,'<span class="com">$1</span>');
          out = out.replace(/([a-zA-Z\-]+)(?=\s*:)/g,'<span class="prop">$1</span>');
          out = out.replace(/("([^"\\]|\\.)*"|'([^'\\]|\\.)*')/g,'<span class="str">$1</span>');
          out = out.replace(/\b(\d+(\.\d+)?)(px|rem|em|%)?\b/g,'<span class="num">$1$3</span>');
        } else {
          out=out.replace(/(\/\*[\s\S]*?\*\/|\/\/[^\n]*)/g,m=>`<span class="com">${m.replace(/</g,'&lt;')}</span>`);
          out=out.replace(/("([^"\\]|\\.)*"|'([^'\\]|\\.)*'|`([^`\\]|\\.)*`)/g,m=>`<span class="str">${m.replace(/</g,'&lt;')}</span>`);
          out=out.replace(/\b([0-9]+(?:\.[0-9]+)?)\b/g,`<span class="num">$1</span>`);
          out=out.replace(/\bclass\s+([A-Za-z_$][\w$]*)/g,(_,n)=>`class <span class="cls">${n}</span>`);
          out=out.replace(/\bfunction\s+([A-Za-z_$][\w$]*)\s*\(/g,(_,n)=>`function <span class="fn">${n}</span>(`);
          out=out.replace(/([A-Za-z_$][\w$]*)\s*=\s*\(.*?\)\s*=>/g,m=>m.replace(/([A-Za-z_$][\w$]*)/,`<span class="fn">$1</span>`));
          const keywords=['const','let','var','return','if','else','for','while','switch','case','break','continue','class','new','try','catch','finally','throw','await','async','import','from','export','extends','super','this','typeof','instanceof','in'];
          const kwRegex=new RegExp('\\b('+keywords.join('|')+')\\b','g');
          out=out.replace(kwRegex,`<span class="kw">$1</span>`);
        }
        const lines = out.split(/\r\n|\r|\n/);
        return lines.map(line => `<div>${line || '&nbsp;'}</div>`).join('');
      }

      function highlightJS(src){
        return highlightCode(src, currentEditorPath || '');
      }

      function getTextFromContentEditable(el){
        let txt=el.innerText||el.textContent||'';
        txt=txt.replace(/\r\n/g,'\n').replace(/\r/g,'\n');
        return txt;
      }
      function placeCaretAtEnd(el){ el.focus(); if(window.getSelection&&document.createRange){ const r=document.createRange(); r.selectNodeContents(el); r.collapse(false); const s=window.getSelection(); s.removeAllRanges(); s.addRange(r);} }
      function startSimulatedProgress(from=0,to=90,duration=400){
        if(simInterval){ clearInterval(simInterval); simInterval=null; }
        let pct=from; const steps=Math.max(8,Math.floor(duration/80)); const step=(to-from)/steps;
        simInterval=setInterval(()=>{ pct=Math.min(99,pct+step); setProgress(Math.round(pct)); if(pct>=to){ clearInterval(simInterval); simInterval=null; } }, Math.max(40, Math.floor(duration/steps)));
      }
    </script>
    <script>
/* Ascunde .dock când orice .modal-overlay este vizibilă */
(function () {
  function setDockHidden(hidden) {
    const dock = document.querySelector('.dock');
    if (!dock) return;
    dock.style.display = hidden ? 'none' : '';
  }

  function isAnyModalVisible() {
    const overlays = document.querySelectorAll('.modal-overlay');
    for (const el of overlays) {
      // Considerăm vizibil dacă are .show SAU display != none
      if (el.classList.contains('show')) return true;
      const cs = getComputedStyle(el);
      if (cs.display !== 'none' && cs.visibility !== 'hidden' && cs.opacity !== '0') {
        return true;
      }
    }
    return false;
  }

  function updateDockVisibility() {
    setDockHidden(isAnyModalVisible());
  }

  // Observăm schimbări pe atributele modalelelor (class/style/aria-hidden)
  const modalObserver = new MutationObserver(updateDockVisibility);
  function attachModalObservers() {
    document.querySelectorAll('.modal-overlay').forEach(el => {
      modalObserver.observe(el, {
        attributes: true,
        attributeFilter: ['class', 'style', 'aria-hidden']
      });
    });
  }

  // Dacă se adaugă modale noi dinamic
  const docObserver = new MutationObserver(muts => {
    let shouldReattach = false;
    for (const m of muts) {
      if (m.type === 'childList' && (m.addedNodes.length || m.removedNodes.length)) {
        shouldReattach = true;
      }
    }
    if (shouldReattach) attachModalObservers();
    updateDockVisibility();
  });

  document.addEventListener('DOMContentLoaded', () => {
    attachModalObservers();
    docObserver.observe(document.body, { childList: true, subtree: true });
    updateDockVisibility();
  });

  // În caz că modalele sunt închise cu ESC sau prin JS, sincronizăm imediat după tick
  document.addEventListener('keydown', () => setTimeout(updateDockVisibility, 0));

  // Îl expunem ca să-l poți apela manual după open/close dacă vrei
  window.updateDockVisibility = updateDockVisibility;
})();
</script>

    <script src="https://kit.fontawesome.com/6bcbc61285.js" crossorigin="anonymous"></script>
  </body>
</html>
